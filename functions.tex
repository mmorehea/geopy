\clearpage\subsection{Opening and closing \geosteiner{} environment}
\label{environment_functions}
The \geosteiner{} environment encapsulates licensing information and 
platform-specific data. If CPLEX is used as LP solver, the CPLEX
environment is stored in the \geosteiner{} environment. 

The environment is a single {\em global} variable. No explicit user
references to the environment are possible, but the environment {\em
  must} be initialized by calling the {\bf gst\_open\_geosteiner()}
function before any other library functions can be invoked.

In the reminder of this section, we present each of the functions in
the library related to the \geosteiner{} environment.

\clearpage\func{gst\_open\_geosteiner}
\label{gst_open_geosteiner}
\index{gst\_open\_geosteiner}

\hrule
\vskip 0.25in
\geosteiner{} can be in two major states {\em open} or {\em closed}.  The
initial state is always {\em closed}.  This routine transitions
\geosteiner{} from the {\em closed} state to the {\em open} state by 
initializing the \geosteiner{} environment.
No other \geosteiner{} library function may be called when \geosteiner{} is 
{\em closed}.  In a multi-threaded environment, it is the
application's responsibility to ensure that no calls to other
\geosteiner{} library functions are either pending or initiated until
\geosteiner{} is in the {\em open} state --- which begins as soon as
this routine returns with a status code of zero.

Note that the function does {\em not} open the LP solver
(e.g., CPLEX). This is done automatically the first time the LP solver
environment is accessed; however, it can also be done explicitly
using the {\bf gst\_open\_lpsolver()} function.
An existing CPLEX environment can also be attached to the \geosteiner{} 
environment.  See {\bf gst\_attach\_cplex()}; this is only relevant
for CPLEX versions of the library.

\begin{verbatim}
int gst_open_geosteiner (void);

\end{verbatim}
Returns status code (which is zero if \geosteiner{} was successfully opened).

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
if (gst_open_geosteiner()) {
   printf("GeoSteiner was not opened successfully.\n");
   exit(1);
}
\end{verbatim}
}
\clearpage\func{gst\_close\_geosteiner}
\label{gst_close_geosteiner}
\index{gst\_close\_geosteiner}

\hrule
\vskip 0.25in
Transition \geosteiner{} from the {\em open} to the {\em closed} state.
Conceptually, \geosteiner{} enters the {\em closed} state the
very instant this routine is called. 
In a multi-threaded environment, it is the application's
responsibility to ensure that no calls to other \geosteiner{} library
functions are pending at the time this routine is invoked. 

\begin{verbatim}
int gst_close_geosteiner (void);

\end{verbatim}
Returns error code (which is zero if \geosteiner{} was successfully closed).

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
if (gst_close_geosteiner()) {
   printf("GeoSteiner was not closed successfully.\n");
   exit(1);
}
\end{verbatim}
}
\clearpage\func{gst\_version\_string}
\label{gst_version_string}
\index{gst\_version\_string}

\hrule
\vskip 0.25in
Return \geosteiner{} version number as a character string.

\begin{verbatim}
const char * gst_version_string (void);

\end{verbatim}
Returns null-terminated string giving the \geosteiner{} version number.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
printf ("This is GeoSteiner version %s\n", gst_version_string());
\end{verbatim}
}
\clearpage\func{gst\_version}
\label{gst_version}
\index{gst\_version}

\hrule
\vskip 0.25in
Return \geosteiner{} version number as an integer with the following
decimal interpretation: XXXYYYZZZ, where XXX is the major version, YYY
is the minor version and ZZZ is the patch-level.

\begin{verbatim}
int gst_version (void);

\end{verbatim}
Returns integer representing the version number.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int version = gst_version();
printf ("This is GeoSteiner version %d.%d.%d\n", 
        (version / 1000000),
        (version / 1000) % 1000,
        (version % 1000));
\end{verbatim}
}
\clearpage\func{gst\_open\_lpsolver}
\label{gst_open_lpsolver}
\index{gst\_open\_lpsolver}

\hrule
\vskip 0.25in
Initialize LP solver (e.g., CPLEX) environment. It is not necessary to
open the LP solver explicitly, since this is done automatically the
first time the LP solver is needed. However, it might be advantageous to
ensure that the LP solver has been successfully opened and is available
for use before starting a long run.

\begin{verbatim}
int gst_open_lpsolver (void);

\end{verbatim}
Returns value zero if the LP solver was opened successfully or already
was open.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
if (gst_open_geosteiner()) {
   printf("GeoSteiner was not opened successfully.\n");
   exit(1);
}
if (gst_open_lpsolver()) {
   printf("LP solver was not initialized successfully.\n");
   exit(1);
}
/* At this point both GeoSteiner and the LP solver are opened... */
\end{verbatim}
}
\clearpage\func{gst\_close\_lpsolver}
\label{gst_close_lpsolver}
\index{gst\_close\_lpsolver}

\hrule
\vskip 0.25in
Close LP solver environment. In the case where the LP solver was
{\em attached}, e.g., using {\bf gst\_attach\_cplex()}, then this
routine detaches but does {\em not} close the LP solver.

\begin{verbatim}
int gst_close_lpsolver (void);

\end{verbatim}
Returns value zero if the solver was closed successfully or already
was closed. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
if (gst_close_geosteiner()) {
   printf("LP solver could not be closed successfully.\n");
   exit(1);
}
\end{verbatim}
}
\clearpage\func{gst\_lpsolver\_version\_string}
\label{gst_lpsolver_version_string}
\index{gst\_lpsolver\_version\_string}

\hrule
\vskip 0.25in
Return the name of the configured LP solver and its version number as a
string.

\begin{verbatim}
const char* gst_lpsolver_version_string (void);

\end{verbatim}
Returns zero-terminated string giving the LP solver name and version.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
printf ("GeoSteiner used LP solver %s\n",
        gst_lpsolver_version_string());
\end{verbatim}
}
\clearpage\func{gst\_attach\_cplex}
\label{gst_attach_cplex}
\index{gst\_attach\_cplex}

\hrule
\vskip 0.25in
Provided only for CPLEX versions of the library.  Attach an existing
CPLEX environment to \geosteiner.  Certain applications may wish to use
CPLEX before, during and/or after they use \geosteiner.  This function
permits such applications to use an existing CPLEX environment rather
than letting \geosteiner{} attempt to open CPLEX itself (which would
fail if CPLEX were already open). A non-\code{NULL} CPLEX environment
that was attached using {\bf gst\_attach\_cplex()} will not be closed
when {\bf gst\_close\_geosteiner()} is called. 

\begin{verbatim}
void gst_attach_cplex (struct cpxenv*  envp);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{envp} &
\adescr{CPLEX environment to be attached.  }\\
\hline
\end{tabular}

No return value.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that envp is an existing CPLEX environment...*/

/* Open GeoSteiner */
if (gst_open_geosteiner()) {
   printf("GeoSteiner was not opened successfully.\n");
   exit(1);
}

/* Attach existing CPLEX environment */
gst_attach_cplex(envp);

/* Now envp is the CPLEX environment used by GeoSteiner... */

/* Detach CPLEX environment and close GeoSteiner */
gst_detach_cplex();
gst_close_geosteiner();
\end{verbatim}
}
\clearpage\func{gst\_detach\_cplex}
\label{gst_detach_cplex}
\index{gst\_detach\_cplex}

\hrule
\vskip 0.25in
Provided only for CPLEX versions of the library. Detach and return a
previously attached CPLEX environment. Does not close the CPLEX
environment. 

\begin{verbatim}
struct cpxenv* gst_detach_cplex ();

\end{verbatim}
Return value is \code{NULL} if no CPLEX environment is currently attached.

An example is given with the documentation of {\bf
gst\_attach\_cplex()} on page~\pageref{gst_attach_cplex}.

\clearpage\subsection{High-level optimization functions}
\label{high_level_functions}
The high-level functions give the user easy access to the basic
algorithms in the library. There are two types of functions:
Firstly, there are functions that solve Steiner tree problems in the
plane by passing a set of point coordinates; secondly, the MSTHG
problem can be solved by giving a description of the hypergraph
instance. 

All functions have a parameter set as argument. This parameter set can
be created and modified using the functions described in
Section~\ref{parameter_functions}. However, default parameters are
used for all parameters if a \code{NULL} pointer is passed as
parameter set.
 

\clearpage\func{gst\_smt}
\label{gst_smt}
\index{gst\_smt}

\hrule
\vskip 0.25in
Given a set of points (or terminals) in the plane, construct an SMT for the
points. The metric used for the SMT construction must be specified.
(Dedicated functions for specific metrics are given on the following pages.)
The length of the constructed SMT, the Steiner points and the list of
line segments in the SMT are returned.

Any of the output parameters may be set to \code{NULL} if the corresponding
output is not needed. It is the responsibility of the user to allocate
sufficient memory for the output arrays.
\vspace*{-0.3cm}

\begin{verbatim}
int gst_smt (int             nterms,
             double*         terms,
             double*         length,
             int*            nsps,
             double*         sps,
             int*            nedges,
             int*            edges,
             int*            status,
             gst_metric_ptr  metric,
             gst_param_ptr   param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of points (or terminals). }\\
\hline
\code{terms} &
\adescr{Input point coordinates ($x_1, y_1, x_2, y_2, \ldots$). }\\
\hline
\code{length} &
\adescr{Length of computed SMT. }\\
\hline
\code{nsps} &
\adescr{Number of Steiner points. }\\
\hline
\code{sps} &
\adescr{Steiner point coordinates.  }\\
\hline
\code{edges} &
\adescr{Edges of SMT (terminals have index 0 to \code{nterms}-1 while Steiner points have index \code{nterms} and up). }\\
\hline
\code{status} &
\adescr{Solution status code (see page~\pageref{gst_get_solver_status}). }\\
\hline
\code{metric} &
\adescr{Metric object (see Section~\ref{metric_functions}). }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters).  }\\
\hline
\end{tabular}

Returns value zero if an SMT was computed and non-zero otherwise.
See Figure~\ref{fig:demo2} on page~\pageref{fig:demo2} or the example
file \code{demo2.c} for an example of how to use {\bf gst\_smt()}.

\clearpage\func{gst\_esmt}
\label{gst_esmt}
\index{gst\_esmt}

\hrule
\vskip 0.25in
Given a set of points (or terminals) in the plane, construct an {\em
Euclidean} SMT for the points. The length of the constructed SMT, the
Steiner points and the list of line segments in the SMT are returned.

Any of the output parameters may be set to \code{NULL} if the corresponding
output is not needed. It is the responsibility of the user to allocate
sufficient memory for the output arrays.

\begin{verbatim}
int gst_esmt (int            nterms, 
              double*        terms, 
              double*        length,
              int*           nsps,  
              double*        sps, 
              int*           nedges,
              int*           edges, 
              int*           status,
              gst_param_ptr  param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of points (or terminals). }\\
\hline
\code{terms} &
\adescr{Input point coordinates ($x_1, y_1, x_2, y_2, \ldots$). }\\
\hline
\code{length} &
\adescr{Length of computed SMT. }\\
\hline
\code{nsps} &
\adescr{Number of Steiner points. }\\
\hline
\code{sps} &
\adescr{Steiner point coordinates.  }\\
\hline
\code{edges} &
\adescr{Edges of SMT (terminals have index 0 to \code{nterms}-1 while Steiner points have index \code{nterms} and up). }\\
\hline
\code{status} &
\adescr{Solution status code (see page~\pageref{gst_get_solver_status}). }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters).  }\\
\hline
\end{tabular}

Returns value zero if an SMT was computed and non-zero otherwise.

An example is given in Section~\ref{high_level_interfaces}.

\clearpage\func{gst\_rsmt}
\label{gst_rsmt}
\index{gst\_rsmt}

\hrule
\vskip 0.25in
Given a set of points (or terminals) in the plane, construct a {\em
rectilinear} SMT for the points. The length of the constructed SMT,
the Steiner points and the list of line segments in the SMT are
returned.

Any of the output parameters may be set to \code{NULL} if the corresponding
output is not needed. It is the responsibility of the user to allocate
sufficient memory for the output arrays.

\begin{verbatim}
int gst_rsmt (int            nterms,
              double*        terms,
              double*        length,
              int*           nsps,
              double*        sps,
              int*           nedges,
              int*           edges,
              int*           status,
              gst_param_ptr  param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of points (or terminals). }\\
\hline
\code{terms} &
\adescr{Input point coordinates ($x_1, y_1, x_2, y_2, \ldots$). }\\
\hline
\code{length} &
\adescr{Length of computed SMT. }\\
\hline
\code{nsps} &
\adescr{Number of Steiner points. }\\
\hline
\code{sps} &
\adescr{Steiner point coordinates.  }\\
\hline
\code{edges} &
\adescr{Edges of SMT (terminals have index 0 to \code{nterms}-1 while Steiner points have index \code{nterms} and up). }\\
\hline
\code{status} &
\adescr{Solution status code (see page~\pageref{gst_get_solver_status}). }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters).  }\\
\hline
\end{tabular}

Returns value zero if an SMT was computed and non-zero otherwise.

An example is given in Section~\ref{high_level_interfaces}.

\clearpage\func{gst\_osmt}
\label{gst_osmt}
\index{gst\_osmt}

\hrule
\vskip 0.25in
Given a set of points (or terminals) in the plane, construct an {\em 
octilinear} SMT for the points.  The length of the constructed SMT, the
Steiner points and the list of line segments in the SMT are returned.

Any of the output parameters may be set to \code{NULL} if the corresponding
output is not needed. It is the responsibility of the user to allocate
sufficient memory for the output arrays.

\begin{verbatim}
int gst_osmt (int            nterms,
              double*        terms,
              double*        length,
              int*           nsps,
              double*        sps,
              int*           nedges,
              int*           edges,
              int*           status,
              gst_param_ptr  param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of points (or terminals). }\\
\hline
\code{terms} &
\adescr{Input point coordinates ($x_1, y_1, x_2, y_2, \ldots$). }\\
\hline
\code{length} &
\adescr{Length of computed SMT. }\\
\hline
\code{nsps} &
\adescr{Number of Steiner points. }\\
\hline
\code{sps} &
\adescr{Steiner point coordinates.  }\\
\hline
\code{edges} &
\adescr{Edges of SMT (terminals have indices 0 to \code{nterms}-1 while Steiner points have indices \code{nterms} and up). }\\
\hline
\code{status} &
\adescr{Solution status code (see page~\pageref{gst_get_solver_status}). }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters).  }\\
\hline
\end{tabular}

Returns value zero if an SMT was computed and non-zero otherwise.

An example is given in Section~\ref{high_level_interfaces}.

\clearpage\func{gst\_hgmst}
\label{gst_hgmst}
\index{gst\_hgmst}

\hrule
\vskip 0.25in
Given an edge-weighted hypergraph, construct a minimum spanning tree
(MST) in this hypergraph.

Any of the output parameters may be set to \code{NULL} if the corresponding
output is not needed. It is the responsibility of the user to allocate
sufficient memory for the output arrays.

\begin{verbatim}
int gst_hgmst (int            nverts,
               int            nedges,
               int*           edge_sizes,
               int*           edges,
               double*        weights,
               double*        length,
               int*           nmstedges,
               int*           mstedges,
               int*           status,
               gst_param_ptr  param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nverts} &
\adescr{Number of vertices in the hypergraph. }\\
\hline
\code{nedges} &
\adescr{Number of edges in the hypergraph. }\\
\hline
\code{edge\_sizes} &
\adescr{Array giving number of vertices in each edge }\\
\hline
\code{edges} &
\adescr{Array of vertices contained in each edge. }\\
\hline
\code{weights} &
\adescr{Array of edge weights. }\\
\hline
\code{nmstedges} &
\adescr{Number of edges in the minimum spanning tree. }\\
\hline
\code{mstedges} &
\adescr{Array of edges contained in the minimum spanning tree. }\\
\hline
\code{status} &
\adescr{Solution status code (see page~\pageref{gst_get_solver_status}). }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters).  }\\
\hline
\end{tabular}

Returns value zero if an MST was computed and non-zero otherwise.

\bigskip\bigskip\bigskip\bigskip % Just to move example to next page

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
static int edge_sizes [] = {2, 2, 2, 3};
static int edges [] = {0, 1,        /* edge 0 */
                       0, 2,        /* edge 1 */
                       1, 2,        /* edge 2 */
                       0, 1, 2};    /* edge 3 */
static double weights [] = {3.0, 2.0, 1.0, 4.0};
double length;
int code, i, nmstedges, mstedges [2];

code = gst_hgmst (3,       /* nverts */
                  4,       /* nedges */
                  edge_sizes,
                  edges,
                  weights,
                  &length,
                  &nmstedges,
                  mstedges,
                  NULL,    /* ignore status */
                  NULL);   /* use default parameters */
if (code != 0) {
        fprintf (stderr, "Return code = %d\n", code);
        exit (1);
}
printf ("Optimal solution = %g: ", length);
for (i = 0; i < nmstedges; i++) {
        printf (" %d", mstedges [i]);
}
printf ("\n");
\end{verbatim}
}
\clearpage\subsection{Parameter setting and querying functions}
\label{parameter_functions}
A parameter set is an object that holds values for all parameters in the
library.
The library provides the following operations on parameter sets:
\begin{itemize}
  \item create a parameter set having ``default'' values,
  \item change parameter settings in a parameter set,
  \item query the current, default, minimum and maximum values
        of any parameter,
  \item query the type of a parameter,
  \item copy an existing parameter set,
  \item free a parameter set.
\end{itemize}
Parameter sets have type \code{gst\_param\_ptr}. Various library
functions require a parameter set to be provided as 
an argument. In all such cases it is valid for the caller to pass a
\code{NULL} pointer, in which case default settings will be used for all
parameters.

Each supported parameter has a specific type.  When querying the type of
a parameter, the library responds with an integer value that denotes the
corresponding parameter type.  The parameter types supported, together
with the integer values that denote them are as follows:

\begin{center}
 {\ttfamily
  \label{tab:parmtypes}
  \begin{tabular}{llr}
   {\bf Type}		& {\bf Macro Name}		& {\bf Value} \\
   \hline
   int			& GST\_PARAMTYPE\_INTEGER	&	1 \\
   double		& GST\_PARAMTYPE\_DOUBLE	&	2 \\
   char*		& GST\_PARAMTYPE\_STRING	&	3 \\
   gst\_channel\_ptr	& GST\_PARAMTYPE\_CHANNEL	&	4 \\
  \end{tabular}
 }
\end{center}

Externally each parameter has a unique number defined by a
\code{GST\_PARAM} macro (see Appendix~\ref{parameters}). This macro is
used as an argument to the parameter get/set functions. Note that
there are distinct parameter get/set functions for each parameter
type.

\clearpage\func{gst\_create\_param}
\label{gst_create_param}
\index{gst\_create\_param}

\hrule
\vskip 0.25in
Create a new parameter set with default parameters.

\begin{verbatim}
gst_param_ptr gst_create_param (int*  status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{status} &
\adescr{Status code (zero if operation was successful and non-zero otherwise).  }\\
\hline
\end{tabular}

Returns new parameter set with default parameters.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int status;

/* Create a default parameter set */
gst_param_ptr myparam = gst_create_param(&status);

/* Change one parameter to a non-default value */
gst_set_int_param(myparam, GST_MAX_FST_SIZE, 4);

/* Use the new parameter set...*/
\end{verbatim}
}
\clearpage\func{gst\_copy\_param}
\label{gst_copy_param}
\index{gst\_copy\_param}

\hrule
\vskip 0.25in
Copy all parameter values from one parameter set into another.

\begin{verbatim}
int gst_copy_param (gst_param_ptr  dst,
                    gst_param_ptr  src);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{dst} &
\adescr{Parameter set that should be overwritten. 	If \code{NULL}, this routine does nothing. }\\
\hline
\code{src} &
\adescr{Parameter set that should be copied. A \code{NULL} pointer is handled as the default set of parameters.  }\\
\hline
\end{tabular}

Returns zero if the parameter set was copied successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that param1 is an existing parameter set */

gst_param_ptr param2 = gst_create_param(NULL);
if (gst_copy_param (param2, param1)) {
   printf("Could not copy parameter set.\n");
   exit(1);
}

/* At this point param2 is a copy of param1 */
\end{verbatim}
}
\clearpage\func{gst\_free\_param}
\label{gst_free_param}
\index{gst\_free\_param}

\hrule
\vskip 0.25in
Free parameter set.  Freeing a parameter set that is still referenced
by any other \geosteiner{} object (e.g., by a problem solution state
object) produces undefined behavior. 

\begin{verbatim}
int gst_free_param (gst_param_ptr  param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set that should be freed.  If \code{NULL}, this routine does nothing.  }\\
\hline
\end{tabular}

Returns zero if the parameter set was freed successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Free existing parameter set myparam */
gst_free_param(myparam);
\end{verbatim}
}
\clearpage\func{gst\_set\_dbl\_param}
\label{gst_set_dbl_param}
\index{gst\_set\_dbl\_param}

\hrule
\vskip 0.25in
Change value of a specified double parameter in a given parameter set.

\begin{verbatim}
int gst_set_dbl_param (gst_param_ptr  param,
                       int            whichparam,
                       double         newvalue);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of double parameter to modify (\code{GST\_PARAM} macro). }\\
\hline
\code{newvalue} &
\adescr{New value for this parameter.  }\\
\hline
\end{tabular}

Returns zero if the parameter was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Set a CPU time limit of 0.5 seconds for parameter set myparam */
gst_set_dbl_param(myparam, GST_PARAM_CPU_LIMIT, 0.5);
\end{verbatim}
}
\clearpage\func{gst\_get\_dbl\_param}
\label{gst_get_dbl_param}
\index{gst\_get\_dbl\_param}

\hrule
\vskip 0.25in
Get current value of a specified double parameter from a given parameter set.

\begin{verbatim}
int gst_get_dbl_param (gst_param_ptr  param,
                       int            whichparam,
                       double*        value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of double parameter to access (\code{GST\_PARAM} macro). }\\
\hline
\code{value} &
\adescr{Current value of parameter (pointer to double variable).  }\\
\hline
\end{tabular}

Returns zero if the parameter was accessed successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
double cpulimit;
gst_get_dbl_param(myparam, GST_PARAM_CPU_LIMIT, &cpulimit);
printf ("The current CPU time limit is %.2f.\n", cpulimit);
\end{verbatim}
}
\clearpage\func{gst\_query\_dbl\_param}
\label{gst_query_dbl_param}
\index{gst\_query\_dbl\_param}

\hrule
\vskip 0.25in
Query properties of a specified double parameter in a given parameter set.

\begin{verbatim}
int gst_query_dbl_param (gst_param_ptr  param,
                         int            whichparam,
                         double*        current_value,
                         double*        default_value,
                         double*        min_value,
                         double*        max_value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of double parameter to query (\code{GST\_PARAM} macro). }\\
\hline
\code{current\_value} &
\adescr{Current value of parameter (pointer to double variable). }\\
\hline
\code{default\_value} &
\adescr{Default value of parameter (pointer to double variable). }\\
\hline
\code{min\_value} &
\adescr{Minimum value of parameter (pointer to double variable). }\\
\hline
\code{max\_value} &
\adescr{Maximum value of parameter (pointer to double variable).  }\\
\hline
\end{tabular}

Each of the last four arguments may be \code{NULL} if the
corresponding value is not needed.

Returns zero if the parameter was queried successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* myparam is an existing parameter set */
double curval, defval, minval, maxval;
if (gst_query_dbl_param (myparam,
                         GST_PARAM_GAP_TARGET,
                         &curval,
                         &defval,
                         &minval,
                         &maxval) != 0) {
        fprintf (stderr, "Parameter query failed.\n");
        exit (1);
}
printf ("Gap target: current=%g, default=%g, min=%g, max=%g.\n",
        curval, defval, minval, maxval);
\end{verbatim}
}
\clearpage\func{gst\_set\_int\_param}
\label{gst_set_int_param}
\index{gst\_set\_int\_param}

\hrule
\vskip 0.25in
Change value of a specified integer parameter in a given parameter set.

\begin{verbatim}
int gst_set_int_param (gst_param_ptr  param,
                       int            whichparam,
                       int            newvalue);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of	integer parameter to modify (\code{GST\_PARAM} macro). }\\
\hline
\code{newvalue} &
\adescr{New value for this parameter.  }\\
\hline
\end{tabular}

Returns zero if the parameter was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Collect the 10 best solutions. */
gst_set_int_param (myparam, GST_PARAM_NUM_FEASIBLE_SOLUTIONS, 10);
\end{verbatim}
}
\clearpage\func{gst\_get\_int\_param}
\label{gst_get_int_param}
\index{gst\_get\_int\_param}

\hrule
\vskip 0.25in
Get current value of a specified integer parameter from a given parameter
set.

\begin{verbatim}
int gst_get_int_param (gst_param_ptr  param,
                       int            whichparam,
                       int*           value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of integer parameter to access (\code{GST\_PARAM} macro). }\\
\hline
\code{value} &
\adescr{Current value of parameter (pointer to integer variable).  }\\
\hline
\end{tabular}

Returns zero if the parameter was accessed successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int vlimit;
gst_get_int_param(myparam, GST_PARAM_BACKTRACK_MAX_VERTS, &vlimit);
printf ("The current backtrack search vertex limit is %d.\n", vlimit);
\end{verbatim}
}
\clearpage\func{gst\_query\_int\_param}
\label{gst_query_int_param}
\index{gst\_query\_int\_param}

\hrule
\vskip 0.25in
Query properties of a specified integer parameter in a given parameter
set.

\begin{verbatim}
int gst_query_int_param (gst_param_ptr  param,
                         int            whichparam,
                         int*           current_value,
                         int*           default_value,
                         int*           min_value,
                         int*           max_value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of integer parameter to query (\code{GST\_PARAM} macro).  }\\
\hline
\code{current\_value} &
\adescr{Current value of parameter (pointer to integer variable). }\\
\hline
\code{default\_value} &
\adescr{Default value of parameter (pointer to integer variable). }\\
\hline
\code{min\_value} &
\adescr{Minimum value of parameter (pointer to integer variable). }\\
\hline
\code{max\_value} &
\adescr{Maximum value of parameter (pointer to integer variable).  }\\
\hline
\end{tabular}

Each of the last four arguments may be \code{NULL} if the corresponding
value is not needed.

Returns zero if the parameter was queried successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* param is an existing parameter set */
int curval, defval, minval, maxval;
if (gst_query_int_param (param,
                         GST_PARAM_BRANCH_VAR_POLICY,
                         &curval,
                         &defval,
                         &minval,
                         &maxval) != 0) {
        fprintf (stderr, "Parameter query failed.\n");
        exit (1);
}
printf ("Branch variable policy: "
        "current=%g, default=%g, min=%g, max=%g.\n",
        curval, defval, minval, maxval);
\end{verbatim}
}
\clearpage\func{gst\_set\_str\_param}
\label{gst_set_str_param}
\index{gst\_set\_str\_param}

\hrule
\vskip 0.25in
Change value of a specified string parameter in a given parameter set.

\begin{verbatim}
int gst_set_str_param (gst_param_ptr  param, 
                       int            whichparam, 
                       const char*    str);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of string parameter to access (\code{GST\_PARAM} macro). }\\
\hline
\code{chan} &
\adescr{New value for this parameter.  }\\
\hline
\end{tabular}

Returns zero if the parameter was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Establish a name for my problem instance. */
#define MY_INSTANCE_NAME_PARAM  -123
int code;
code = gst_set_str_param (myparam,
                          MY_INSTANCE_NAME_PARAM,
                          "Bowser");
if (code != 0) {
        fprintf (stderr, "gst_set_str_param failed.\n");
        exit (1);
}
\end{verbatim}
}
\clearpage\func{gst\_get\_str\_param}
\label{gst_get_str_param}
\index{gst\_get\_str\_param}

\hrule
\vskip 0.25in
Get current value of a specified string parameter in a given parameter
set.

\begin{verbatim}
int gst_get_str_param (gst_param_ptr  param, 
                       int            whichparam,
                       int*           length,
                       char*          str);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of string parameter to access (\code{GST\_PARAM} macro). }\\
\hline
\code{length} &
\adescr{The length of the string is written to this integer (unless it is a \code{NULL} pointer). A length of \code{-1} indicates that the parameter has the value \code{NULL}, which is distinct from a string of length zero. }\\
\hline
\code{str} &
\adescr{The current value for this parameter is copied to the string provided here (unless it is a \code{NULL} pointer).  }\\
\hline
\end{tabular}

Returns zero if the parameter was accessed successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
#define MY_INSTANCE_NAME_PARAM  -123
int code, length;
char* value;

/* First, get length of the string. */
gst_set_str_param (myparam,
                   MY_INSTANCE_NAME_PARAM,
                   &length,
                   NULL);
value = NULL;
if (length >= 0) {
        /* Allocate buffer to receive string value. */
        value = (char *) malloc (length + 1);
        code = gst_set_str_param (myparam,
                                  MY_INSTANCE_NAME_PARAM,
                                  NULL,
                                  value);
}
printf ("My problem instance name = %s\n",
        (value == NULL) ? "<null>" : value);
if (value != NULL) {
        free (value);
}
\end{verbatim}
}
\clearpage\func{gst\_set\_chn\_param}
\label{gst_set_chn_param}
\index{gst\_set\_chn\_param}

\hrule
\vskip 0.25in
Change value of a specified channel parameter in a given parameter set.

\begin{verbatim}
int gst_set_chn_param (gst_param_ptr    param,
                       int              whichparam,
                       gst_channel_ptr  chan);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of a channel parameter to modify (\code{GST\_PARAM} macro). }\\
\hline
\code{chan} &
\adescr{New value for this parameter.  }\\
\hline
\end{tabular}

Returns zero if the parameter was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int code;
gst_channel_ptr chan;

/* Create a channel directed to stdout. */
chan = gst_create_channel (NULL, NULL);
gst_channel_add_file (chan, stdout, NULL);

/* Direct solver trace info to stdout. */
code = gst_set_chn_param (myparam, GST_PARAM_PRINT_SOLVE_TRACE, chan);
if (code != 0) {
        fprintf (stderr, "gst_set_chn_param failed.\n");
        exit (1);
}
\end{verbatim}
}
\clearpage\func{gst\_get\_chn\_param}
\label{gst_get_chn_param}
\index{gst\_get\_chn\_param}

\hrule
\vskip 0.25in
Get current value of a specified channel parameter from a given parameter
set.

\begin{verbatim}
int gst_get_chn_param (gst_param_ptr     param,
                       int               whichparam,
                       gst_channel_ptr*  chan);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{whichparam} &
\adescr{Parameter ID of channel parameter to access (\code{GST\_PARAM} macro). }\\
\hline
\code{chan} &
\adescr{Current value for this parameter (pointer to channel variable).  }\\
\hline
\end{tabular}

Returns zero if the parameter was accessed successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int code;
gst_channel_ptr chan;

/* Get current solver trace channel. */
code = gst_get_chn_param (myparam, 
                          GST_PARAM_PRINT_SOLVE_TRACE, 
                          &chan);
if (code != 0) {
        fprintf (stderr, "gst_get_chn_param failed.\n");
        exit (1);
}
if (chan != NULL) {
        /* Turn off the trace and destroy the channel. */
        gst_set_chn_param (myparam, 
                           GST_PARAM_PRINT_SOLVE_TRACE, 
                           NULL);
        gst_free_channel (chan);
}
\end{verbatim}
}
\clearpage\func{gst\_get\_param\_id}
\label{gst_get_param_id}
\index{gst\_get\_param\_id}

\hrule
\vskip 0.25in
Translate a parameter name into the corresponding parameter id.

\begin{verbatim}
int gst_get_param_id (const char*       param_name,
                      int*              param_id);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param\_name} &
\adescr{The name of a parameter (e.g., "max\_fst\_size", or "GST\_PARAM\_MAX\_FST\_SIZE"). }\\
\hline
\code{param\_id} &
\adescr{Address of an integer to store the parameter ID corresponding to the given parameter name.  This will be -1 for unknown or unrecognizable parameter names.  The \code{param\_id} argument can be \code{NULL}, if the actual parameter ID value is not required.  }\\
\hline
\end{tabular}

Returns zero if the \code{param\_name} was recognized and the parameter
ID was successfully found.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
        int parmid;
        if (gst_get_param_id ("save_format", &parmid) != 0) {
                fprintf (stderr, "gst_get_param_id failed.\n");
                exit (1);
        }
        printf ("Parameter ID: %d\n", parmid);
\end{verbatim}
}
\clearpage\func{gst\_get\_param\_type}
\label{gst_get_param_type}
\index{gst\_get\_param\_type}

\hrule
\vskip 0.25in
Get the type of a specified parameter id.

\begin{verbatim}
int gst_get_param_type (int   whichparam,
                        int*  type);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{whichparam} &
\adescr{Parameter ID to query (\code{GST\_PARAM} macro). }\\
\hline
\code{type} &
\adescr{This integer is set to the type of the parameter. The parameter types and their encodings as integer values are given in the table on page~\pageref{tab:parmtypes}.  }\\
\hline
\end{tabular}

Returns zero if the type was found successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
char* str;
int parmtype;
if (gst_get_param_type (GST_PARAM_SAVE_FORMAT, &parmtype) != 0) {
        fprintf (stderr, "gst_get_param_type failed.\n");
        exit (1);
}
switch (parmtype) {
        case GST_PARAMTYPE_INTEGER:  str = "int";     break;
        case GST_PARAMTYPE_DOUBLE:   str = "double";  break;
        case GST_PARAMTYPE_STRING:   str = "string";  break;
        case GST_PARAMTYPE_CHANNEL:  str = "channel"; break;
        default:                     str = "unknown"; break;
}
printf ("Parameter is of type %s.\n", str);
\end{verbatim}
}
\clearpage\func{gst\_set\_param}
\label{gst_set_param}
\index{gst\_set\_param}

\hrule
\vskip 0.25in
Set the value of a named parameter from the given string.  This
routine permits the value of any integer, double or string parameter
to be set to the value given in text string form.  This is a
convenient way to set parameters from command line arguments.

\begin{verbatim}
int gst_set_param (gst_param_ptr  param,
                   const char*    name,
                   const char*    value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{name} &
\adescr{Name of parameter to set (see Appendix~\ref{parameters}). }\\
\hline
\code{value} &
\adescr{Text string containing data value to set.  }\\
\hline
\end{tabular}


\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int main (int argc, char **argv)
{
int             i, j;
char *          ap;
gst_channel_ptr myparm;

        gst_open_geosteiner (NULL);
        myparam = gst_create_param (NULL);
 
        /* Parse arguments such as: -ZBRANCH_VAR_POLICY 3 */
        for (i = 1; i < argc; i++) {
                ap = argv [i];
                if ((ap[0] != '-') || (ap[1] != 'Z')) usage ();
                j = gst_set_param (myparam, &ap[2], argv [i+1]);
                if (j != 0) usage ();
                ++i;
        }
        /* Parameters are now set... */
}
\end{verbatim}
}
\clearpage\subsection{Metric setting and querying functions}
\label{metric_functions}

The support of different metrics in the \geosteiner{} library is primarily
handled by metric objects. Some functions in the library use these metric
objects automatically, e.g., {\bf gst\_esmt()}, while others require one to
specify a metric object, e.g., {\bf gst\_smt()}. The metric objects provide a
simple way to make general applications support several different metrics. An
example of this can be found in the demo program \code{demo2.c} which
is the code for a small program supporting all metrics supported by \geosteiner.

Two $L_p$-metrics, $L_1$ (rectilinear) and $L_2$ (Euclidean), are
supported. Also, all uniform metrics --- so-called
$\lambda$-metrics --- are supported. The latter are metrics where only
a limited number $\lambda \geq 2$ of equally-spaced orientations are
allowed for the edges in a solution. For $\lambda = 2$ this is
identical to the rectilinear metric, $L_1$. 

When a metric object has been created, the distance between two points
in the metric can be obtained by calling {\bf gst\_distance()}. This 
is especially useful for the $\lambda$-metrics for which efficient
calculation is non-trivial.

The following macros are used for identifying the supported metrics:
\begin{center}
 \begin{tabular}{llr}
  \label{tab:metrictypes}
  {\bf Metric Type} & {\bf Macro Name} & {\bf Value} \\
  \hline
  None	&	\code{GST\_METRIC\_NONE}    &	\code{0} \\
  $L_p$	&	\code{GST\_METRIC\_L}	    &	\code{1} \\
  Uniform &	\code{GST\_METRIC\_UNIFORM} &	\code{2} \\
 \end{tabular}
\end{center}

\clearpage\func{gst\_create\_metric}
\label{gst_create_metric}
\index{gst\_create\_metric}

\hrule
\vskip 0.25in
A metric is defined by a type and a parameter. For the $L_p$-metric
this parameter $p$ must be either 1 or 2, and for the $\lambda$-metric
we must have $\lambda \geq 2$.

Note that even though the $L_1$-metric and the $\lambda$-metric
with parameter 2 are the same (rectilinear metric), you cannot expect
them to give exactly the same results when used to solve Steiner
problems. The first one will result in the use of a dedicated FST
generator for the rectilinear problem and the latter will result in
the use of a general FST generator for $\lambda$-metrics. If you are
aiming for speed then use the $L_1$-metric. 

\begin{verbatim}
gst_metric_ptr gst_create_metric (int   type,
                                  int   parameter,
                                  int*  status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{type} &
\adescr{Metric type (see macro values in the table on page~\pageref{tab:metrictypes}).  }\\
\hline
\code{parameter} &
\adescr{Metric parameter. }\\
\hline
\code{status} &
\adescr{Status code (zero if operation was successful and non-zero otherwise).  }\\
\hline
\end{tabular}

Returns new metric object.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Creating a Euclidean metric object */
gst_metric_ptr	metric;
metric = gst_create_metric (GST_METRIC_L, 2, NULL);

/* And use it as a parameter to gst_smt */
gst_smt (nterms, terms, &length, NULL, NULL, NULL, NULL, NULL,
         metric, NULL);
\end{verbatim}
}
\clearpage\func{gst\_free\_metric}
\label{gst_free_metric}
\index{gst\_free\_metric}

\hrule
\vskip 0.25in
Free an existing metric object. Freeing a metric object that is still
referenced by any other \geosteiner{} object (e.g., a hypergraph
object) produces undefined behavior.

\begin{verbatim}
int gst_free_metric (gst_metric_ptr  metric);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{metric} &
\adescr{Metric object. Does nothing if \code{NULL}.  }\\
\hline
\end{tabular}

Returns zero if operation was successful.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Free parameter object mymetric */
gst_free_metric (mymetric);
\end{verbatim}
}
\clearpage\func{gst\_copy\_metric}
\label{gst_copy_metric}
\index{gst\_copy\_metric}

\hrule
\vskip 0.25in
Copy attributes from one metric object to another.

\begin{verbatim}
int gst_copy_metric (gst_metric_ptr  dst, 
                     gst_metric_ptr  src);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{dst} &
\adescr{Metric object that should be overwritten. }\\
\hline
\code{src} &
\adescr{Metric that should be copied. A \code{NULL} pointer is considered as a "None" metric type (see table on page~\pageref{tab:metrictypes}).    }\\
\hline
\end{tabular}

Returns zero if metric object was copied.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
gst_metric_ptr newmetric;

newmetric = gst_create_metric (GST_METRIC_NONE, 0);

gst_copy_metric (newmetric, oldmetric);

/* newmetric is now the same metric as oldmetric. */
\end{verbatim}
}
\clearpage\func{gst\_distance}
\label{gst_distance}
\index{gst\_distance}

\hrule
\vskip 0.25in
Compute the distance between two points under a given metric.

\begin{verbatim}
double gst_distance (gst_metric_ptr  metric,
                     double          x1,
                     double          y1,
                     double          x2,
                     double          y2);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{metric} &
\adescr{Metric object. }\\
\hline
\code{x1} &
\adescr{X-coordinate for first point. }\\
\hline
\code{y1} &
\adescr{Y-coordinate for first point. }\\
\hline
\code{x2} &
\adescr{X-coordinate for second point. }\\
\hline
\code{y2} &
\adescr{Y-coordinate for second point.  }\\
\hline
\end{tabular}

Returns the distance. Returned value is always zero if metric type is "None".

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that mymetric is a metric object. */
/* Compute distance between points (0,0) and (1,1). */
double d;
d = gst_distance (mymetric, 0.0, 0.0, 1.0, 1.0);
\end{verbatim}
}
\clearpage\func{gst\_get\_metric\_info}
\label{gst_get_metric_info}
\index{gst\_get\_metric\_info}

\hrule
\vskip 0.25in
Get the information about a metric object.

\begin{verbatim}
int gst_get_metric_info (gst_metric_ptr  metric,
                         int*            type,
                         int*            parameter);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{metric} &
\adescr{Metric object. }\\
\hline
\code{type} &
\adescr{A pointer to an integer in which to place the metric type. See the possible types in the table on page~\pageref{tab:metrictypes}. }\\
\hline
\code{parameter} &
\adescr{An optional pointer to an integer in which to place the metric parameter. See the possible parameters in the description of {\bf gst\_create\_metric()}.  }\\
\hline
\end{tabular}

Returns zero if operation was successful. Either of the last two
arguments may be \code{NULL} if the corresponding value is not needed.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Let mymetric be a metric object */
int type, parameter;
gst_get_metric_info (mymetric, &type, &parameter);
switch (type) {
        case GST_METRIC_NONE:
                printf ("Metric is None.\n");
                break;
        case GST_METRIC_L:
                printf ("Metric is L%d.\n", parameter);
                break;
        case GST_METRIC_UNIFORM:
                printf ("Metric is Uniform %d.\n", parameter);
                break;
        default:
                printf ("Metric is unknown!\n");
}
\end{verbatim}
}
\clearpage\subsection{Property list setting and querying functions}
\label{proplist_functions}
Property lists can be used to hold values which are rarely updated (the
data structure holding the information {\em cannot} be queried/updated in
constant time). The following basic operations are provided by the library:
\begin{itemize}
  \item create an empty property list,
  \item set/create a value in a property list,
  \item delete a value from a property list,
  \item get a value in a property list,
  \item query the type of a property,
  \item copy a property list,
  \item free a property list (including its content).
\end{itemize}
A property list has type \code{gst\_proplist\_ptr} and a property is known by
its property ID (a macro name which expands to a signed integer).

The main purpose of property lists is to make extra information about the
solution process available to the user through a simple interface. Any property
ID with a value larger than or equal to zero is reserved by the library.
Negative values can be freely used by the user. The property ID values (and
their macro names) currently in use can be found in
Appendices~\ref{hypergraph_properties} and ~\ref{solver_properties}.

Note that there are distinct property get/set functions for different
property types. The type of a given property --- which is an integer
--- can be queried. The supported property types, together with the
integer values that denote them are as follows:

\begin{center}
 {\ttfamily
  \label{tab:proptypes}
  \begin{tabular}{llr}
   {\bf Type}		& {\bf Macro Name}		& {\bf Value} \\
   \hline
   int			& GST\_PROPTYPE\_INTEGER	&	1 \\
   double		& GST\_PROPTYPE\_DOUBLE		&	2 \\
   char*		& GST\_PROPTYPE\_STRING		&	3 \\
  \end{tabular}
 }
\end{center}

\clearpage\func{gst\_create\_proplist}
\label{gst_create_proplist}
\index{gst\_create\_proplist}

\hrule
\vskip 0.25in
Create a new empty property list.

\begin{verbatim}
gst_proplist_ptr 
    gst_create_proplist (int*  status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{status} &
\adescr{Status code (zero if operation was successful and non-zero otherwise). May be \code{NULL} if value is not needed.  }\\
\hline
\end{tabular}

Returns new property list.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
gst_proplist_ptr plist;
int status;
plist = gst_create_proplist (&status);
if (status != 0) {
        fprintf (stderr, "Unable to create property list.\n");
        exit (1);
}
gst_set_int_property (plist, GST_PROP_SOLVER_ROOT_OPTIMAL, 1);
\end{verbatim}
}
\clearpage\func{gst\_free\_proplist}
\label{gst_free_proplist}
\index{gst\_free\_proplist}

\hrule
\vskip 0.25in
Free an existing property list.  Freeing a property list that is still
referenced by existing GeoSteiner objects (e.g., hypergraphs and
solvers) results in undefined behavior. In most cases it is an error to
free a property list that was not obtained via a call to
{\bf gst\_create\_proplist()}.

\begin{verbatim}
int gst_free_proplist (gst_proplist_ptr  plist);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{A property list to free. If \code{NULL}, this routine does nothing.  }\\
\hline
\end{tabular}

Returns a status code (zero if operation was successful and non-zero otherwise).

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
gst_proplist_ptr plist;
plist = gst_create_proplist (NULL);

/* Various operations on plist... */

gst_free_proplist (plist);
\end{verbatim}
}
\clearpage\func{gst\_copy\_proplist}
\label{gst_copy_proplist}
\index{gst\_copy\_proplist}

\hrule
\vskip 0.25in
Empty the destination property list and copy all properties into it from
the source property list.

\begin{verbatim}
int gst_copy_proplist (gst_proplist_ptr  dst,
                       gst_proplist_ptr  src);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{dst} &
\adescr{Property list that should be overwritten. }\\
\hline
\code{src} &
\adescr{Property list that should be copied. A \code{NULL} pointer is handled as an empty property list.  }\\
\hline
\end{tabular}

Returns zero if the property list was copied successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We assume that H is a hypergraph... */
gst_proplist_ptr copy;

copy = gst_create_proplist (NULL);

if (gst_copy_proplist (copy, gst_get_hg_properties(H)) == 0) {
   /* We have now created a copy of the property list for H */
}
else {
   /* Something went wrong */
}

/* Use new copy of property list... */

/* Free copy */
gst_free_proplist (copy);
\end{verbatim}
}
\clearpage\func{gst\_get\_property\_type}
\label{gst_get_property_type}
\index{gst\_get\_property\_type}

\hrule
\vskip 0.25in
Query the type of a given property.

\begin{verbatim}
int gst_get_property_type (gst_proplist_ptr  plist,
                           int               propid,
                           int*              type);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{An existing property list. }\\
\hline
\code{propid} &
\adescr{A property ID value. }\\
\hline
\code{type} &
\adescr{Pointer to an integer which will be overwritten with the type of the property.  }\\
\hline
\end{tabular}

Return a status code (zero if operation was successful and non-zero otherwise).

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We assume that H is a hypergraph... */
int type;

if (gst_get_property_type (gst_get_hg_properties(H),
                           GST_PROP_HG_GENERATION_TIME,
                           &type) != 0) {
   /* Something went wrong */
}
else {
   switch (type) {
   case GST_PROPTYPE_INTEGER: /* Property is an integer value */
      break;
   case GST_PROPTYPE_DOUBLE:  /* Property is a floating point value */
      break;
   case GST_PROPTYPE_STRING:  /* Property is a string value */
      break;
   default: /* Something went wrong */
   }
}
\end{verbatim}
}
\clearpage\func{gst\_delete\_property}
\label{gst_delete_property}
\index{gst\_delete\_property}

\hrule
\vskip 0.25in
Remove any value that might be defined for the given property ID,
regardless of type.

\begin{verbatim}
int gst_delete_property (gst_proplist_ptr   plist,
                         int                propid);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of property to delete.  }\\
\hline
\end{tabular}

Returns zero if the property was successfully deleted from the property
list.\\
Returns \code{GST\_ERR\_INVALID\_PROPERTY\_LIST} if the property list
itself is invalid.\\
Returns \code{GST\_ERR\_PROPERTY\_NOT\_FOUND} if no property having the
given ID exists.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We are given a property list plist */
#define MY_PROPERTY_ID  -1000

gst_delete_property (plist, MY_PROPERTY_ID);

/* plist no longer has any value defined */
/* for property ID -1000. */
\end{verbatim}
}
\clearpage\func{gst\_get\_dbl\_property}
\label{gst_get_dbl_property }
\index{gst\_get\_dbl\_property}

\hrule
\vskip 0.25in
Get the value of a specified double property from a given property
list.  The specified property must be of type double or an error
is returned.
ID values greater than or equal to zero are reserved for \geosteiner's
use.
Negative ID values can be freely used by user applications.

\begin{verbatim}
int gst_get_dbl_property (gst_proplist_ptr  plist, 
                          int               propid,
                          double*           value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of double property to retrieve. }\\
\hline
\code{value} &
\adescr{Current value of property (pointer to double variable).  May be \code{NULL} if value is not needed.  }\\
\hline
\end{tabular}

Returns zero if the property was accessed successfully.\\
Returns \code{GST\_ERR\_PROPERTY\_NOT\_FOUND} if no property having the
given ID exists.\\
Returns \code{GST\_ERR\_PROPERTY\_TYPE\_MISMATCH} if the property exists but
does not have type double.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We are given a property list plist and a double value has 
   been set for the ID value GST_PROP_USER_MYVALUE */ 
#define GST_PROP_USER_MY_DBL_VALUE   -1000

double value;
gst_get_dbl_property (plist,
                      GST_PROP_USER_MY_DBL_VALUE,
                      &value);
printf ("My_dbl_value is currently set at %.2f.\n", value);
\end{verbatim}
}
\clearpage\func{gst\_get\_int\_property}
\label{gst_get_int_property }
\index{gst\_get\_int\_property}

\hrule
\vskip 0.25in
Get the value of a specified property from the given property list.
The specified property must be of type integer or an error is
returned.
ID values greater than or equal to zero are reserved for \geosteiner's
use.
Negative ID values can be freely used by user applications.

\begin{verbatim}
int gst_get_int_property (gst_proplist_ptr  plist, 
                          int               propid,
                          int*              value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of integer property to retrieve. }\\
\hline
\code{value} &
\adescr{Current value of property (pointer to integer variable).  May be \code{NULL} if value is not needed.  }\\
\hline
\end{tabular}

Returns zero if the property was accessed successfully.\\
Returns \code{GST\_ERR\_PROPERTY\_NOT\_FOUND} if no property having the
given ID exists.\\
Returns \code{GST\_ERR\_PROPERTY\_TYPE\_MISMATCH} if the property exists but
does not have type integer.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We are given a property list plist and an integer value has 
   been set for the ID value GST_PROP_USER_MY_INT_VALUE */ 
#define GST_PROP_USER_MY_INT_VALUE   -1001

int value;
gst_get_int_property (plist,
                      GST_PROP_USER_MY_INT_VALUE,
                      &value);
printf ("My_int_value is currently set at %d.\n", value);
\end{verbatim}
}
\clearpage\func{gst\_get\_str\_property}
\label{gst_get_str_property }
\index{gst\_get\_str\_property}

\hrule
\vskip 0.25in
Get the value of a specified property from the given property list.
The specified property must be of type string or an error is
returned.
ID values greater than or equal to zero are reserved for \geosteiner's
use.
Negative ID values can be freely used by user applications.

\begin{verbatim}
int gst_get_str_property (gst_proplist_ptr  plist,
                          int               propid,
                          int*              length,
                          char*             str);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of string property to retrieve. }\\
\hline
\code{length} &
\adescr{The length of the string is written to this integer (unless it is a \code{NULL} pointer).  The returned length does {\em not} include the terminating null character. The returned length is -1 if the property value is a \code{NULL} pointer (which is distinct from a zero length string). }\\
\hline
\code{str} &
\adescr{The current value for this parameter is copied into the buffer provided here (unless it is a \code{NULL} pointer).  }\\
\hline
\end{tabular}

Returns zero if the property was accessed successfully.\\
Returns \code{GST\_ERR\_PROPERTY\_NOT\_FOUND} if no property having the
given ID exists.\\
Returns \code{GST\_ERR\_PROPERTY\_TYPE\_MISMATCH} if the property exists but
does not have type string.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int code, length;
char* buf;
buf = NULL;
code = gst_get_str_property (plist, GST_PROP_HG_NAME, 
                             &length, NULL);
if ((code == 0) && (length >= 0)) {
        buf = (char *) malloc (length + 1);
        gst_get_str_property (plist,
                              GST_PROP_HG_NAME,
                              NULL,
                              buf);
}
printf ("Hypergraph name is %s\n",
        (buf == NULL) ? "<NULL>" : buf);
if (buf != NULL) free (buf);
\end{verbatim}
}
\clearpage\func{gst\_get\_properties}
\label{gst_get_properties}
\index{gst\_get\_properties}

\hrule
\vskip 0.25in
Retrieve all property IDs and their types from the given property list.

\begin{verbatim}
int gst_get_properties (gst_proplist_ptr  plist,
                        int*              count,
                        int*              propids,
                        int*              types);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{count} &
\adescr{Number of properties in the given \code{plist} (unless it is a \code{NULL} pointer). }\\
\hline
\code{propids} &
\adescr{Buffer to receive the property IDs of each property in \code{plist} (unless it is a \code{NULL} pointer). }\\
\hline
\code{types} &
\adescr{Buffer to receive the types of each property in \code{plist} (unless it is a \code{NULL} pointer).  }\\
\hline
\end{tabular}

Returns zero if the properties were successfully retrieved.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int count;
int* propids;
int* types;
code = gst_get_properties (plist, &count, NULL, NULL);
if (code != 0) {
       /* Something went wrong. */
       exit (1);
}
propids = (int *) malloc (count * sizeof (int));
types   = (int *) malloc (count * sizeof (int));
gst_get_properties (plist, NULL, propids, types);
for (i = 0; i < count; i++) {
        printf ("Propid = %d, type = %d.\n", 
                propids [i], types [i]);
}
free (types);
free (propids);
\end{verbatim}
}
\clearpage\func{gst\_set\_dbl\_property}
\label{gst_set_dbl_property}
\index{gst\_set\_dbl\_property}

\hrule
\vskip 0.25in
Change or create a specified property in the given property list.
The property is added to the list if not already present. If the
property already exists, its type is forced to be double.
It is {\em legal} to do this with any property list.

\begin{verbatim}
int gst_set_dbl_property (gst_proplist_ptr  plist, 
                          int               propid, 
                          double            value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of double property to create or modify. }\\
\hline
\code{newvalue} &
\adescr{New value for this property.  }\\
\hline
\end{tabular}

Returns zero if the property was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume we are given a property list plist */
#define GST_PROP_USER_MY_DBL_VALUE   -1000

gst_set_dbl_property (plist, GST_PROP_USER_MY_DBL_VALUE, 2.71828);
\end{verbatim}
}
\clearpage\func{gst\_set\_int\_property}
\label{gst_set_int_property}
\index{gst\_set\_int\_property}

\hrule
\vskip 0.25in
Change or create a a specified property in the given property list.
The property is added to the list if not already present. If the
property already exists, its type is forced to be integer.
It is {\em legal} to do this with any property list.

\begin{verbatim}
int gst_set_int_property (gst_proplist_ptr  plist, 
                          int               propid, 
                          int               value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of integer property to create or modify. }\\
\hline
\code{newvalue} &
\adescr{New value for this property.  }\\
\hline
\end{tabular}

Returns zero if the property was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume we are given a property list plist */
#define GST_PROP_USER_MY_INT_VALUE   -1001

gst_set_int_property (plist, GST_PROP_USER_MY_INT_VALUE, 42);
\end{verbatim}
}
\clearpage\func{gst\_set\_str\_property}
\label{gst_set_str_property}
\index{gst\_set\_str\_property}

\hrule
\vskip 0.25in
Change or create a specified property in the given property list.
The property is added to the list if not already present. If the
property already exists, its type is forced to be string.
It is {\em legal} to do this with any property list.

\begin{verbatim}
int gst_set_str_property (gst_proplist_ptr  plist, 
                          int               propid, 
                          const char*       value);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{plist} &
\adescr{Property list. }\\
\hline
\code{propid} &
\adescr{ID of string property to create or modify. }\\
\hline
\code{newvalue} &
\adescr{New value for this property.  }\\
\hline
\end{tabular}

Returns zero if the property was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume we are given a property list plist */
gst_set_str_property (plist, GST_PROP_HG_NAME, "Oobleck");
\end{verbatim}
}
\clearpage\subsection{Hypergraph functions}
\label{hypergraph_functions}

The hypergraph object represents an arbitrary hypergraph that can be
decorated with a variety of additional (and optional) data.  For
example, the edges can be given weights.  In general, the goal of
\geosteiner{} is to find a spanning tree of minimum total weight using the
edges of the hypergraph.

In this section we document all of the operations provided for creating,
destroying and manipulating hypergraph objects.

Hypergraphs can be embedded in the plane: Vertices can be given
coordinates and hyperedges can be associated with trees in the plane. 
Also, every hypergraph has an associated metric object
(Section~\ref{metric_functions}), a scaling object
(Section~\ref{io_functions}) and a property list
(Section~\ref{proplist_functions}). 

The library interfaces have been designed to permit maximum flexibility
in using the various operations provided.  For example, it is
intended that the user be able to define a hypergraph, solve it, modify
some attributes of the hypergraph (e.g., change some of the edge costs),
and re-solve the modified problem.  The library should be 
smart enough to know when the problem can be re-solved starting from the
most recent solution state --- and when it is necessary to discard the
previous solution state and re-solve the current problem from scratch.

\clearpage\func{gst\_create\_hg}
\label{gst_create_hg}
\index{gst\_create\_hg}

\hrule
\vskip 0.25in
Create an instance of an empty hypergraph.  The hypergraph initially has
no vertices and no edges.  After creating an empty hypergraph, the next
step is normally to give it the desired number of vertices
using {\bf gst\_set\_hg\_number\_of\_vertices()}, and then add the
edges using {\bf gst\_set\_hg\_edges()}. Doing the steps in this order
avoids the failure that would result from attempting to add edges that
refer to non-existent vertices.

\begin{verbatim}
gst_hg_ptr gst_create_hg (int*  status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{status} &
\adescr{Status code (zero if the operation was successful and non-zero otherwise). May be \code{NULL} if the value is not needed.  }\\
\hline
\end{tabular}

Returns new hypergraph object.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
gst_hg_ptr h;
int status;
h = gst_create_hg (&status);
if (status != 0) {
        /* Something went wrong */
}
/* Make it be a complete hypergraph on 3 vertices */
status = gst_set_hg_number_of_vertices (h, 3);
if (status != 0) {
        /* Error */
}
else {
        static int edge_sizes [] = {2, 2, 2, 3};
        static int edges [] = {0, 1, 0, 2, 1, 2, 0, 1, 2};
        status = gst_set_hg_edges (h, 4, edge_sizes, edges, NULL);
}
\end{verbatim}
}
\clearpage\func{gst\_copy\_hg}
\label{gst_copy_hg}
\index{gst\_copy\_hg}

\hrule
\vskip 0.25in
Make a copy of a given hypergraph. Any data associated with the
destination hypergraph is discarded, and the following attributes are
copied from the source hypergraph (if present): vertices, edges, edge
weights, metric object info, scale object info, property list, vertex
embedding, and edge embedding.

\begin{verbatim}
int gst_copy_hg (gst_hg_ptr  dst,
                 gst_hg_ptr  src);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{dst} &
\adescr{Destination hypergraph object. All existing data in the destination is discarded. }\\
\hline
\code{src} &
\adescr{Source hypergraph object to copy.  }\\
\hline
\end{tabular}

Returns zero if the hypergraph was copied successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph */
gst_hg_ptr newhg;
newhg = gst_create_hg (NULL);
status = gst_copy_hg (newhg, h);
if (status != 0) {
        fprintf (stderr, "Error copying hypergraph\n");
        exit (1);
}
gst_set_hg_edge_weights (newhg, NULL);
/* newhg is now a copy of h, but with all edge weights = 1. */
\end{verbatim}
}
\clearpage\func{gst\_copy\_hg\_edges}
\label{gst_copy_hg_edges}
\index{gst\_copy\_hg\_edges}

\hrule
\vskip 0.25in
Make a copy of a given hypergraph with a subset of the original edges.
Any data associated with the destination hypergraph is
discarded, and the following attributes are copied from the source
hypergraph (if present): vertices, (subset of) edges, (subset of) edge
weights, metric object info, scale object info, property list, vertex 
embedding, and edge embedding. 

\begin{verbatim}
int gst_copy_hg_edges (gst_hg_ptr  dst, 
                       gst_hg_ptr  src, 
                       int         nedges, 
                       int*        edges);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{dst} &
\adescr{Destination hypergraph object. All existing data in the destination is discarded. }\\
\hline
\code{src} &
\adescr{Source hypergraph object to copy. }\\
\hline
\code{nedges} &
\adescr{Number of edges to copy from source hypergraph. }\\
\hline
\code{edges} &
\adescr{Index values of edges to copy from source hypergraph.  }\\
\hline
\end{tabular}

Returns zero if (a subset of) the hypergraph was copied successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph with 10 edges */
static int edges [] = {2, 4, 6, 8};
gst_hg_ptr newhg;
newhg = gst_create_hg (NULL);
status = gst_copy_hg_edges (newhg, h, 4, edges);
if (status != 0) {
        fprintf (stderr, "Error copying hypergraph\n");
        exit (1);
}
/* newhg is now a copy of h but having only 4 of the edges of h */
\end{verbatim}
}
\clearpage\func{gst\_free\_hg}
\label{gst_free_hg}
\index{gst\_free\_hg}

\hrule
\vskip 0.25in
Remove a hypergraph and free all associated memory, including associated
properties. 

\begin{verbatim}
int gst_free_hg (gst_hg_ptr  H);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph to free. If \code{NULL}, this function does nothing.   }\\
\hline
\end{tabular}

Returns zero if the hypergraph was freed successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph */
int status;
status = gst_free_hg (h);
if (status != 0) {
        fprintf (stderr, "Error freeing hypergraph\n");
        exit (1);
}
\end{verbatim}
}
\clearpage\func{gst\_set\_hg\_number\_of\_vertices}
\label{gst_set_hg_number_of_vertices}
\index{gst\_set\_hg\_number\_of\_vertices}

\hrule
\vskip 0.25in
Define the number of vertices of a hypergraph.

\begin{verbatim}
int gst_set_hg_number_of_vertices (gst_hg_ptr  H,
                                   int         nverts);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{nverts} &
\adescr{Number of vertices \code{H} should have (non-negative number).  }\\
\hline
\end{tabular}

Returns zero if the number of vertices was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Construct a hypergraph with 20 vertices (no error checking) */
gst_hg_ptr hg;

hg = gst_create_hg (NULL);
gst_set_hg_number_of_vertices (hg, 20);
\end{verbatim}
}
\clearpage\func{gst\_set\_hg\_edges}
\label{gst_set_hg_edges}
\index{gst\_set\_hg\_edges}

\hrule
\vskip 0.25in
Define the set of edges of a hypergraph (default associated
information). 

\begin{verbatim}
int gst_set_hg_edges (gst_hg_ptr  H,
                      int         nedges,
                      int*        edge_sizes,
                      int*        edges,
                      double*     weights);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{nedges} &
\adescr{Number of edges \code{H} should have. }\\
\hline
\code{edge\_sizes} &
\adescr{Number of vertices for each edge. }\\
\hline
\code{edges} &
\adescr{Vertex indices of each edge.  }\\
\hline
\code{weights} &
\adescr{Edge weights (if \code{NULL} then all edge weights are 1).  }\\
\hline
\end{tabular}

Returns zero if the edges were defined successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Construct a complete hypergraph on 3 vertices 
   with edge weights 1 (no error checking) */

gst_hg_ptr h;
static int edge_sizes [] = {2, 2, 2, 3};
static int edges [] = {0, 1, 0, 2, 1, 2, 0, 1, 2};

h = gst_create_hg (NULL);
gst_set_hg_number_of_vertices (h, 3);
gst_set_hg_edges (h, 4, edge_sizes, edges, NULL);
\end{verbatim}
}
\clearpage\func{gst\_set\_hg\_edge\_weights}
\label{gst_set_hg_edge_weights}
\index{gst\_set\_hg\_edge\_weights}

\hrule
\vskip 0.25in
Set all edge weights of a hypergraph. 

\begin{verbatim}
int gst_set_hg_edge_weights (gst_hg_ptr  H,
                             double*     weights);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{weights} &
\adescr{Array of edge weights of length equal to the number of edges in \code{H} (if \code{NULL} then all edge weights are set to 1).  }\\
\hline
\end{tabular}

Returns zero if the edges weights were set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is a hypergraph with 4 edges */

static double weights [] = {1.0, 2.0, 3.0, 4.0};
int status;

status = gst_set_hg_edge_weights (h, weights);
if (status != 0) {
        fprintf (stderr, "Error setting edge weights\n");
        exit (1);
}
/* The edges of h now have weights 1, 2, 3 and 4 */
\end{verbatim}
}
\clearpage\func{gst\_set\_hg\_vertex\_embedding}
\label{gst_set_hg_vertex_embedding}
\index{gst\_set\_hg\_vertex\_embedding}

\hrule
\vskip 0.25in
Embed the vertices in a hypergraph in some $k$-dimensional space.
(In the current version only the $2$-dimensional space, the plane, is
supported.) 

\begin{verbatim}
int gst_set_hg_vertex_embedding (gst_hg_ptr  H,
                                 int         dim,
                                 double*     coords);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph whose vertices should be embedded. }\\
\hline
\code{dim} &
\adescr{Dimension of space (currently only dimension 2 is supported).  }\\
\hline
\code{coords} &
\adescr{Vertex coordinates ($x_1, y_1, x_2, y_2, \ldots$). Length must be the dimension times the number of vertices in the hypergraph.  }\\
\hline
\end{tabular}

Returns zero if the vertices were embedded successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph with four vertices */
static double coords [] = {0, 0, 1, 0, 1, 1, 0, 1};
int status;
status = gst_set_hg_vertex_embedding (h, 2, coords);
if (status != 0) {
        fprintf (stderr, "Error embedding vertices\n");
        exit (1);
}
/* The four vertices of h are now embedded as 
   (0,0), (0,1), (1,1) and (0,1). */
\end{verbatim}
}
\clearpage\func{gst\_set\_hg\_metric}
\label{gst_set_hg_metric}
\index{gst\_set\_hg\_metric}

\hrule
\vskip 0.25in
Set the metric object associated with a hypergraph.

\begin{verbatim}
int gst_set_hg_metric (gst_hg_ptr      H,
                       gst_metric_ptr  metric);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{metric} &
\adescr{Metric object that should be associated with \code{H} (see Section~\ref{metric_functions} for information on metric objects). If \code{NULL}, then the hypergraph metric will be set to "None".  }\\
\hline
\end{tabular}

Returns zero if metric was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph */

/* Create a Euclidean metric object */
gst_metric_ptr metric;
metric = gst_create_metric (GST_METRIC_L, 2, NULL);

/* Associate it with h */
gst_set_hg_metric (h, metric);
\end{verbatim}
}
\clearpage\func{gst\_set\_hg\_scale\_info}
\label{gst_set_hg_scale_info}
\index{gst\_set\_hg\_scale\_info}

\hrule
\vskip 0.25in
Set the scaling information associated with a hypergraph.

\begin{verbatim}
int gst_set_hg_scale_info (gst_hg_ptr          H,
                           gst_scale_info_ptr  scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{scinfo} &
\adescr{Scaling information that should be associated with this hypergraph (see Section~\ref{io_functions}). If \code{NULL}, then no scaling is used for this hypergraph.  }\\
\hline
\end{tabular}

Returns zero if the scaling information was set successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Read a set points from stdin, generate FST hypergraph
   and set scaling information */

gst_hg_ptr hg;
gst_scale_info_ptr scinfo;
int n;
double* terms;

n = gst_get_points (stdin, 0, &terms, scinfo);
hg = gst_generate_efsts (n, terms, NULL, NULL);
gst_set_hg_scale_info (hg, scinfo);
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_terminals}
\label{gst_get_hg_terminals}
\index{gst\_get\_hg\_terminals}

\hrule
\vskip 0.25in
Get terminal vertices for a hypergraph. The terminal indices are
returned in the \code{terms} array. 

\begin{verbatim}
int gst_get_hg_terminals (gst_hg_ptr  H,
                          int*        nterms,
                          int*        terms);

\end{verbatim}
\clearpage\func{gst\_get\_hg\_number\_of\_vertices}
\label{gst_get_hg_number_of_vertices}
\index{gst\_get\_hg\_number\_of\_vertices}

\hrule
\vskip 0.25in
Get the number of vertices of a hypergraph.

\begin{verbatim}
int gst_get_hg_number_of_vertices (gst_hg_ptr  H);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph.  }\\
\hline
\end{tabular}

A return value of -1 implies that the hypergraph was invalid.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that hg is an existing hypergraph */
int nverts;

nverts = gst_get_hg_number_of_vertices (hg);

/* nverts is now equal to the number of vertices in hg */
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_edges}
\label{gst_get_hg_edges}
\index{gst\_get\_hg\_edges}

\hrule
\vskip 0.25in
Get the set of edges of a hypergraph. If any of the three final arguments
is \code{NULL}, the corresponding information is not returned. The
user has to allocate space for holding the returned
data. Necessary sizes for arrays can be obtained by first
obtaining the number of edges, then the edge sizes and finally the
vertices for each edge (see example below).

\begin{verbatim}
int gst_get_hg_edges (gst_hg_ptr  H,
                      int*        nedges,
                      int*        edge_sizes,
                      int*        edges,
                      double*     weight);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{nedges} &
\adescr{Number of edges in this hypergraph. }\\
\hline
\code{edge\_sizes} &
\adescr{Number of vertices for each edge (pointer to an array allocated by the user). }\\
\hline
\code{edges} &
\adescr{Vertex indices of each edges (pointer to an array allocated by the user).  }\\
\hline
\code{weights} &
\adescr{Edge weights (pointer to an array allocated by the user).  }\\
\hline
\end{tabular}

Returns zero if the edges were queried successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that H is some hypergraph */
int i, nedges, nedgeverts;
int* edge_sizes;
int* edges;
double* weight;

/* First we query the number of edges */
gst_get_hg_edges (H, &nedges, NULL, NULL, NULL);

/* Allocate space for edge sizes and edge weights */
edge_sizes = (int *)    malloc (nedges * sizeof (int));
weight     = (double *) malloc (nedges * sizeof (double));

/* Query edge sizes and weights */
gst_get_hg_edges (H, NULL, edge_sizes, NULL, weight);

/* Count the number of vertices in all edges */
nedgeverts = 0;
for (i = 0; i < nedges; i++)
   nedgeverts += edge_sizes[i];
edges = (int *) malloc (nedgeverts * sizeof (int));

/* Finally query vertices of edges */
gst_get_hg_edges (H, NULL, NULL, edges, NULL);
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_one\_edge}
\label{gst_get_hg_one_edge}
\index{gst\_get\_hg\_one\_edge}

\hrule
\vskip 0.25in
Get information about one edge in the hypergraph. If any of the three
last arguments to the function is \code{NULL}, the corresponding
information is not returned. 

\begin{verbatim}
int gst_get_hg_one_edge (gst_hg_ptr  H,
                         int         edge_number,
                         double*     weight,
                         int*        nverts,
                         int*        verts);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{edge\_number} &
\adescr{Edge number to query (first edge is number 0). }\\
\hline
\code{weight} &
\adescr{Weight of edge (pointer to a double variable). }\\
\hline
\code{nverts} &
\adescr{Number of vertices in this edge (pointer to an int variable). }\\
\hline
\code{terms} &
\adescr{Vertex indices of this edges (pointer to an array allocated by user).   }\\
\hline
\end{tabular}

Returns zero if the edge was queried successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that H is some hypergraph with at least 10 edges  */
int nverts;
int* verts;
double weight;

/* Query edge number 10 */
gst_get_hg_one_edge (H, 10, &weight, &nverts, NULL);

/* Allocate space for vertex indices */
verts = (int *) malloc (nverts * sizeof (int));

/* Query vertex indices */
gst_get_hg_one_edge (H, 10, NULL, NULL, verts);
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_vertex\_embedding}
\label{gst_get_hg_vertex_embedding}
\index{gst\_get\_hg\_vertex\_embedding}

\hrule
\vskip 0.25in
Get the embedding of the vertices in a hypergraph.

\begin{verbatim}
int gst_get_hg_vertex_embedding (gst_hg_ptr  H,
                                 int*        dim,
                                 double*     coords);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph whose vertices are embedded. }\\
\hline
\code{dim} &
\adescr{Dimension of the space (pointer to an integer variable). }\\
\hline
\code{coords} &
\adescr{Array in which to place the vertex coordinates of the embedding ($x_1, y_1, x_2, y_2, \ldots$). This array must be allocated by the user, and its length must be dimension times the number of vertices in the hypergraph.   }\\
\hline
\end{tabular}

Returns zero if the embedding was returned successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph with four vertices 
   embedded in the plane */
double coords[8];
int status;

status = gst_get_hg_vertex_embedding(H, NULL, coords);
if (status != 0) {
        fprintf (stderr, "Error querying vertex embedding\n");
        exit (1);
}

/* coords now holds the coordinates of the embedded vertices */
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_one\_vertex\_embedding}
\label{gst_get_hg_one_vertex_embedding}
\index{gst\_get\_hg\_one\_vertex\_embedding}

\hrule
\vskip 0.25in
Return the embedding of a single vertex in a hypergraph.

\begin{verbatim}
int gst_get_hg_one_vertex_embedding 
                        (gst_hg_ptr  H,      
                         int         vertex_number,
                         double*     coords);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph whose vertices are embedded. }\\
\hline
\code{vertex\_number} &
\adescr{Vertex number whose embedding should be queried (first vertex is number 0). }\\
\hline
\code{coords} &
\adescr{Coordinates of the vertex embedding ($x_1, y_1$). This array must be allocated by the user, and its length equal to the dimension of the space of the embedding.  }\\
\hline
\end{tabular}

Returns zero if the embedding was returned successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph with four vertices 
   embedded in the plane */
double coords[2];
int status;

/* Query embedding of vertex number 3 */
status = gst_get_hg_one_vertex_embedding(H, 3, coords);
if (status != 0) {
        fprintf (stderr, "Error querying vertex embedding\n");
        exit (1);
}

/* coords now holds the coordinates of vertex number 3 */
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_edge\_embedding}
\label{gst_get_hg_edge_embedding}
\index{gst\_get\_hg\_edge\_embedding}

\hrule
\vskip 0.25in
Return the embedding of a subset of edges in a hypergraph. If any
of the four last arguments to the function is \code{NULL}, the
corresponding information is not returned. 

\begin{verbatim}
int gst_get_hg_edge_embedding (gst_hg_ptr  H,
                               int         nhgedges,
                               int*        hgedges,
                               int*        nsps,
                               double*     sps,
                               int*        nedges,
                               int*        edges);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph }\\
\hline
\code{nhgedges} &
\adescr{Number of hyperedges that should be queried for embedding information (when equal to 0 all edges are returned). }\\
\hline
\code{hgedges} &
\adescr{List of indices of hyperedges that should be queried. If this argument is \code{NULL} then the first \code{nhgedges} are returned. }\\
\hline
\code{nsps} &
\adescr{Number of Steiner points in embedding of all queried hyperedges (pointer to int variable). }\\
\hline
\code{sps} &
\adescr{Coordinates of Steiner points in the embedded hyperedges (pointer to double array allocated by user). }\\
\hline
\code{nedges} &
\adescr{Number of edges in the {\em embedding} (pointer to int variable). }\\
\hline
\code{edges} &
\adescr{Indices of the edge endpoints in {\em embedding} (pointer to int array allocated by user). Let $n$ be the number of vertices in hypergraph \code{H}. Then hypergraph vertex endpoints have indices $0$ to $n-1$ while Steiner endpoints have indices $n$ and up.  }\\
\hline
\end{tabular}

Returns zero if the embedding was queried successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that H is an embedded hypergraph with 
   5 vertices and 10 edges. The complete embedding 
   has 15 Steiner points and 30 edges. We would like 
   to get the embedding of hyperedges with even indices. */

int nsps;
int nedges;
double sps[30];
int edges[60];

static int hgedges [] = {0, 2, 4, 6, 8};

gst_get_hg_edge_embedding (H, 5, hgedges, 
                           &nsps, sps, &nedges, edges);

/* Now sps contains the Steiner point coordinates,
   while edges contain edge endpoints; hypergraph 
   vertices have endpoint indices 0..4 and Steiner
   points endpoint indices 5..19. */
  
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_one\_edge\_embedding}
\label{gst_get_hg_one_edge_embedding}
\index{gst\_get\_hg\_one\_edge\_embedding}

\hrule
\vskip 0.25in
Return the embedding of a single edge in a hypergraph.
Note that the indices of vertices spanned by an edge can be obtained
by using {\bf gst\_get\_hg\_one\_edge()}.

\begin{verbatim}
int gst_get_hg_one_edge_embedding 
                        (gst_hg_ptr  H,
                         int         edge_number,
                         int*        nsps,
                         double*     coords,
                         int*        nedges,
                         int*        edges);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{edge\_number} &
\adescr{Hyperedge number whose embedding should be queried (first hyperedge has number 0). }\\
\hline
\code{nsps} &
\adescr{Number of Steiner points in the embedding for the hyperedge (pointer to int variable).  }\\
\hline
\code{coords} &
\adescr{Coordinates of Steiner points in embedded hyperedge (pointer to double array allocated by user). }\\
\hline
\code{nedges} &
\adescr{Number of edges in the {\em embedding} (pointer to int variable). }\\
\hline
\code{edges} &
\adescr{Indices of edge endpoints in the {\em embedding} (pointer to int array allocated by user). Let $k$ be the number of vertices in the hyperedge. Then hypergraph vertex endpoints have indices $0$ to $k-1$ while Steiner endpoints have indices $k$ and up.   }\\
\hline
\end{tabular}

Returns zero if embedding was queried successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that H is an embedded hypergraph with 10 edges. 
   We would like to get the embedding of hyperedge 7. */

int nsps;
int nedges;
double* sps;
int* edges;

gst_get_hg_one_edge_embedding (H, 7, &nsps, NULL, &nedges, NULL);

/* Allocate space */
sps   = (double *) malloc (2*nsps   * sizeof (double));
edges = (int *)    malloc (2*nedges * sizeof (int));

gst_get_hg_one_edge_embedding (H, 7, NULL, sps, NULL, edges);

/* Now sps contains the Steiner point coordinates,
   while edges contain edge endpoints. */
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_edge\_status}
\label{gst_get_hg_edge_status}
\index{gst\_get\_hg\_edge\_status}

\hrule
\vskip 0.25in
Return the pruning status of an edge.  When \code{gst\_prune\_edges}
runs, it may determine that some edges are ``required'' (such edges
{\em must} appear in any optimal solution).  It may also determine
that certain other edges are ``unneeded'' (at least one optimal
solution exists that does not use any ``unneeded'' edge).  By default,
edges are neither ``unneeded'' nor ``required.''  It is impossible
for an edge to be simultaneously ``unneeded'' and ``required.''

\begin{verbatim}
int gst_get_hg_edge_status (gst_hg_ptr  H,
                            int         edge_number,
                            int*        unneeded,
                            int*        required);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{edge\_number} &
\adescr{Hyperedge whose pruning status should be queried. }\\
\hline
\code{unneeded} &
\adescr{Non-zero if edge is ``unneeded'' (pointer to an int variable). }\\
\hline
\code{required} &
\adescr{Non-zero if edge is ``required'' (pointer to an int variable).  }\\
\hline
\end{tabular}

Returns zero if pruning status was queried successfully.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that H is an embedded hypergraph with N
   edges that has been pruned.  We would like to
   get the pruning status of its edges. */

int i, unneeded, required;
const char * s;

for (i = 0; i < N; i++) {
  gst_get_hg_edge_status (H, i, &unneeded, &required);
  if (required) {
    s = "required";
  } else if (unneeded) {
    s = "unneeded";
  } else {
    s = "undecided";
  }
  printf (" Edge %d is %s\n", s);
}
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_metric}
\label{gst_get_hg_metric}
\index{gst\_get\_hg\_metric}

\hrule
\vskip 0.25in
Get the metric object associated with a hypergraph.

\begin{verbatim}
int gst_get_hg_metric (gst_hg_ptr       H,
                       gst_metric_ptr*  metric);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{metric} &
\adescr{Metric object associated with this hypergraph (see Section~\ref{metric_functions} for information on metric objects).  }\\
\hline
\end{tabular}

Returns zero if the metric was queried successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph */

gst_metric_ptr metric;

/* Get metric associated with h */
gst_get_hg_metric (h, metric);
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_scale\_info}
\label{gst_get_hg_scale_info}
\index{gst\_get\_hg\_scale\_info}

\hrule
\vskip 0.25in
Get the scaling information associated with a hypergraph.

\begin{verbatim}
int gst_get_hg_scale_info 
                     (gst_hg_ptr           H,
                      gst_scale_info_ptr*  scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{scinfo} &
\adescr{Scaling information associated with this hypergraph (see Section~\ref{io_functions}).  }\\
\hline
\end{tabular}

Returns zero if the scaling information was queried successfully.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that h is an existing hypergraph */

gst_scale_info_ptr scinfo;

/* Get scaling information associated with h */
gst_get_hg_scale_info (h, scinfo);
\end{verbatim}
}
\clearpage\func{gst\_get\_hg\_properties}
\label{gst_get_hg_properties}
\index{gst\_get\_hg\_properties}

\hrule
\vskip 0.25in
Return the list of properties associated with a hypergraph.

\begin{verbatim}
gst_proplist_ptr 
        gst_get_hg_properties (gst_hg_ptr  H);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph  }\\
\hline
\end{tabular}

Returns the property list.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume we are given a hypergraph H */
double gtime, ptime;
gst_proplist_ptr hgprop;

/* Get timing information from the hypergraph, if available */
hgprop = gst_get_hg_properties (H);
gtime = 0.0; ptime = 0.0;
gst_get_dbl_property (hgprop, GST_PROP_HG_GENERATION_TIME, &gtime);
gst_get_dbl_property (hgprop, GST_PROP_HG_PRUNING_TIME, &ptime);

printf ("Generation time: %.2f\n", gtime);
printf ("Pruning time: %.2f\n", ptime);
printf ("Total time: %.2f\n", ptime + gtime);

/* We can set our own property in the same list e.g. for later use */
#define GST_PROP_USER_TOTAL_TIME       -1000
gst_set_dbl_property (hgprop, GST_PROP_USER_TOTAL_TIME, gtime + ptime);
\end{verbatim}
}
\clearpage\func{gst\_hg\_to\_graph}
\label{gst_hg_to_graph}
\index{gst\_hg\_to\_graph}

\hrule
\vskip 0.25in
Given a hypergraph having a geometric embedding for each of its vertices
and edges, construct an ordinary graph
containing the individual edges in the embedding. For a rectilinear
embedding the parameter \code{GST\_PARAM\_GRID\_OVERLAY} is used to specify
that the edges of the reduced grid graph rather than individual edges of the
embedding should be returned.

The original vertices in the hypergraph are marked as {\em terminals} in
the new graph, but the only way\footnote{In a future release of the
library, there will be other means of obtaining this information.} to
get this information out of the new graph is to print it using
function {\bf gst\_save\_hg()}.

\begin{verbatim}
gst_hg_ptr gst_hg_to_graph (gst_hg_ptr     H,
                            gst_param_ptr  param, 
                            int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph }\\
\hline
\code{param} &
\adescr{Parameter set. }\\
\hline
\code{status} &
\adescr{Status code (zero if the operation was successful and non-zero otherwise).   }\\
\hline
\end{tabular}

Returns the new graph which represents the embedding.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume we are given an embedded hypergraph H */

H2 = gst_hg_to_graph (H, NULL, NULL);

/* Now H2 is a graph of the embedding of H. Print it. */
gst_save_hg (stdout, H2, NULL);
\end{verbatim}
}
\clearpage\subsection{FST generation and pruning functions}
\label{fst_functions}

All algorithms for solving geometric Steiner tree problems in
\geosteiner{} use the two-phase approach that consists of full Steiner
tree (FST) generation and concatenation.

FST generation is the process of generating a (hopefully small) set
of FSTs that is known to contain a Steiner minimum tree (SMT) as a
subset. The input to an FST generation algorithm is the set of
terminal points, and the output is an embedded hypergraph in which the
vertices correspond to terminals and the edges correspond to FSTs. The
embedding of each hyperedge (or FST) is the geometric tree structure
of the FST.  

In this section we describe the interface to all FST generation
algorithms. They are all fairly similar. In addition, a FST {\em
pruning} function is given. This function reduces the set of FSTs ---
or removes edges from the hypergraph --- such that the resulting
hypergraph still contains an SMT. This may speed up the following
concatenation algorithm, in particular for very large problem
instances. 

\clearpage\func{gst\_generate\_fsts}
\label{gst_generate_fsts}
\index{gst\_generate\_fsts}

\hrule
\vskip 0.25in
Given a point set (terminals) in the plane, generate a set of FSTs
(hyperedges) known to contain an SMT for the point set. The metric
that should be used is passed as a parameter (see
section~\ref{metric_functions} for more on creating metric objects). 
The generated FSTs are returned as edges in an embedded hypergraph.  

\begin{verbatim}
gst_hg_ptr 
    gst_generate_fsts (int             nterms,
                       double*         terms,
                       gst_metric_ptr  metric,
                       gst_param_ptr   param,
                       int*            status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of terminals. }\\
\hline
\code{terms} &
\adescr{Terminals in an array of doubles ($x_1, y_1, x_2, y_2, \ldots$) }\\
\hline
\code{metric} &
\adescr{The metric for which FSTs are to be generated. }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the resulting FSTs in a hypergraph structure.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int            n;
double *       terms;
gst_hg_ptr     hg;
gst_metric_ptr metric;

/* Read points from stdin */
n = gst_get_points (stdin, 0, &terms, NULL);

/* Establish lambda-6 metric */
metric = gst_create_metric (GST_METRIC_UNIFORM, 6, NULL);

/* Generate lambda-6 FSTs */
hg = gst_generate_fsts (n, terms, metric, NULL, NULL);
\end{verbatim}
}
\clearpage\func{gst\_generate\_efsts}
\label{gst_generate_efsts}
\index{gst\_generate\_efsts}

\hrule
\vskip 0.25in
Given a point set (terminals) in the plane, generate a set of FSTs
(hyperedges) known to contain an {\em Euclidean} SMT for the point
set. The FSTs are returned as edges in an embedded hypergraph.

\begin{verbatim}
gst_hg_ptr 
    gst_generate_efsts (int            nterms,
                        double*        terms,
                        gst_param_ptr  param,
                        int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of terminals. }\\
\hline
\code{terms} &
\adescr{Terminals in an array of doubles ($x_1, y_1, x_2, y_2, \ldots$) }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the resulting FSTs in a hypergraph structure.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int            n;
double *       terms;
gst_hg_ptr     hg;

/* Read points from stdin */
n = gst_get_points (stdin, 0, &terms, NULL);

/* Generate Euclidean FSTs */
hg = gst_generate_efsts (n, terms, NULL, NULL);
\end{verbatim}
}
\clearpage\func{gst\_generate\_rfsts}
\label{gst_generate_rfsts}
\index{gst\_generate\_rfsts}

\hrule
\vskip 0.25in
Given a point set (terminals) in the plane, generate a set of FSTs
(hyperedges) known to contain a {\em rectilinear} SMT for the point
set. The FSTs are returned as edges in an embedded hypergraph.

\begin{verbatim}
gst_hg_ptr 
    gst_generate_rfsts (int            nterms, 
                        double*        terms, 
                        gst_param_ptr  param,
                        int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of terminals. }\\
\hline
\code{terms} &
\adescr{Terminals in an array of doubles ($x_1, y_1, x_2, y_2, \ldots$) }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the resulting FSTs in a hypergraph structure.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int            n;
double *       terms;
gst_hg_ptr     hg;

/* Read points from stdin */
n = gst_get_points (stdin, 0, &terms, NULL);

/* Generate rectilinear FSTs */
hg = gst_generate_rfsts (n, terms, NULL, NULL);
\end{verbatim}
}
\clearpage\func{gst\_generate\_ofsts}
\label{gst_generate_ofsts}
\index{gst\_generate\_ofsts}

\hrule
\vskip 0.25in
Given a point set (terminals) in the plane, generate a set of FSTs
(hyperedges) known to contain an {\em octilinear} SMT for the
point set. The FSTs are returned as edges in an embedded
hypergraph. 

\begin{verbatim}
gst_hg_ptr 
    gst_generate_ofsts (int            nterms, 
                        double*        terms,
                        gst_param_ptr  param, 
                        int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of terminals. }\\
\hline
\code{terms} &
\adescr{Terminals in an array of doubles ($x_1, y_1, x_2, y_2, \ldots$) }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the resulting FSTs in a hypergraph structure.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
int            n;
double *       terms;
gst_hg_ptr     hg;

/* Read points from stdin */
n = gst_get_points (stdin, 0, &terms, NULL);

/* Generate octilinear FSTs */
hg = gst_generate_ofsts (n, terms, NULL, NULL);
\end{verbatim}
}
\clearpage\func{gst\_hg\_prune\_edges}
\label{gst_hg_prune_edges}
\index{gst\_hg\_prune\_edges}

\hrule
\vskip 0.25in
Given a hypergraph $H$, return a hypergraph $H'$ that has the same
vertices as $H$, but a (possibly) reduced set of edges such that there
still exists an optimal solution to $H$ in $H'$. The pruning algorithms
are metric dependent and require a geometric embedding of the hypergraph
vertices and edges.

\begin{verbatim}
gst_hg_ptr gst_hg_prune_edges (gst_hg_ptr     H,
                               gst_param_ptr  param, 
                               int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns new pruned hypergraph.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that hg is an FST hypergraph */

gst_hg_ptr hg1;

/* Prune the set of FSTs in hg */

hg1 = gst_hg_prune_edges (hg, NULL, NULL);

/* Hypergraph hg1 now has the same set of vertices as hg, 
   but (in most cases) a significantly smaller set of edges that
   still contains an SMT as a subset */ 
\end{verbatim}
}
\clearpage\subsection{Hypergraph optimization functions}
\label{solver_functions}

The optimization problem associated with hypergraphs is the {\em
minimum spanning tree (MST) in hypergraph problem}. Solving this problem
solves the FST concatenation problem --- which is the second of the
two phases for solving geometric Steiner tree problems. 

The library contains a powerful solver for the general MST in
hypergraph problem. This solver uses linear programming and
branch-and-cut (or backtrack search for very small problem
instances). A large number of parameters can be set to control the
solver; consult Appendix~\ref{parameters_solver_alg},
\ref{parameters_stop} and \ref{parameters_io} for a complete list of
all solver parameters. 

A solution state object has type \code{gst\_solver\_ptr}. It has an
associated hypergraph for which an MST should be found. The solver can
be stopped and restarted, e.g., depending on either the quality of
(approximate) solutions that are found in the solution process, or on
the amount of running time used. The solution state object can contain zero or
more feasible (though not necessarily optimal) solutions to the
problem. A solution state object refers to both an hypergraph object and a
parameter object (from which all necessary parameter values are
obtained), as illustrated in Figure~\ref{fig:solutionstate} on
page~\pageref{fig:solutionstate}. A demonstration program is given in 
Figure~\ref{fig:demo4} on page~\pageref{fig:demo4}.

\clearpage\func{gst\_create\_solver}
\label{gst_create_solver}
\index{gst\_create\_solver}

\hrule
\vskip 0.25in
Create a solution state object for a given hypergraph. The solution
process is started by calling the function {\bf gst\_hg\_solve()}, and
passing the created object as parameter.

\begin{verbatim}
gst_solver_ptr 
    gst_create_solver (gst_hg_ptr     H, 
                       gst_param_ptr  param,
                       int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{H} &
\adescr{Hypergraph. }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns new problem solution state object.

An example is given in Section~\ref{low_level_interfaces}
(Figure~\ref{fig:demo4} on page~\pageref{fig:demo4}).

\clearpage\func{gst\_free\_solver}
\label{gst_free_solver}
\index{gst\_free\_solver}

\hrule
\vskip 0.25in
Free a solution state object. All memory associated with this solution
state object, except from the associated hypergraph and its objects,
are destroyed.

\begin{verbatim}
int gst_free_solver (gst_solver_ptr  solver);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{solver} &
\adescr{Solution state object. Does nothing if \code{NULL}.   }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

An example is given in Section~\ref{low_level_interfaces}
(Figure~\ref{fig:demo4} on page~\pageref{fig:demo4}).

\clearpage\func{gst\_hg\_solve}
\label{gst_hg_solve}
\index{gst\_hg\_solve}

\hrule
\vskip 0.25in
Solve a tree problem for a given hypergraph. In the current version,
this function by default computes a {\em minimum spanning tree (MST)}
in the hypergraph associated with the given solution state object;
depending on the parameters given, this function may also compute an
heuristic solution to this problem. 

This function can be repeatedly called to solve a (time-consuming)
problem, e.g., by setting a CPU time limit for each call. The quality
of any solution(s) obtained within the given constraints can be
queried by calling {\bf gst\_get\_solver\_status()}.

\begin{verbatim}
int gst_hg_solve (gst_solver_ptr  solver,
                  int *           reason);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{solver} &
\adescr{Solution state object. }\\
\hline
\code{reason} &
\adescr{Reason that the solver exited --- see the description below. If this parameter is \code{NULL}, the reason for exiting is not returned.   }\\
\hline
\end{tabular}

The function return value indicates whether any serious errors were
encountered in the solution process. If this value is zero it means
the solver ran successfully and without problems --- although it might
have deliberately have been preempted by the user.

A non-zero function return value indicates the error causing the
solver to exit prematurely. This could for example be
\code{GST\_ERR\_BACKTRACK\_OVERFLOW} which can happen if one has set
the solver to use backtrack search on an instance which is too big for
this purpose (\code{GST\_PARAM\_SOLVER\_ALGORITHM}), i.e., more than 32
hyperedges. 

When using default parameters (and when not using abort signals) then
a value of zero for the \code{reason} parameter means that the solution 
search space was completely exhausted. In this case the optimal
solution has been found --- unless the problem was found to be infeasible. 
However, if the user has set any of the solver stopping condition
parameters, such as the CPU time limit, the actual 
reason for exiting the solution process is returned using the
\code{reason} parameter. Possible return values are one of the
following:

\bigskip
{\small
\begin{tabular}{|ll|} \hline
{\bf Macro Name}                          & {\bf Description} \\ \hline
\code{GST\_SOLVE\_NORMAL}                 & Normal exit (search space exhausted) \\
\code{GST\_SOLVE\_GAP\_TARGET}            & Requested gap target obtained \\
\code{GST\_SOLVE\_LOWER\_BOUND\_TARGET}   & Requested lower bound obtained \\
\code{GST\_SOLVE\_UPPER\_BOUND\_TARGET}   & Requested upper bound obtained \\
\code{GST\_SOLVE\_MAX\_BACKTRACKS}        & Max.\ number of backtracks exceeded \\
\code{GST\_SOLVE\_MAX\_FEASIBLE\_UPDATES} & Max.\ feasible updates exceeded \\
\code{GST\_SOLVE\_ABORT\_SIGNAL}          & Abort signal received \\
\code{GST\_SOLVE\_TIME\_LIMIT}            & CPU time limit exceeded \\
\hline
\end{tabular}}

An example is given in Section~\ref{low_level_interfaces}
(Figure~\ref{fig:demo4} on page~\pageref{fig:demo4}).

\clearpage\func{gst\_get\_solver\_status}
\label{gst_get_solver_status}
\index{gst\_get\_solver\_status}

\hrule
\vskip 0.25in
Return the status of the solution (if any) associated with the given
solution state object.  

\begin{verbatim}
int gst_get_solver_status (gst_solver_ptr  solver,
                           int*            status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{solver} &
\adescr{Solution state object. }\\
\hline
\code{status} &
\adescr{Status of the current solution (if any).  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

The value of the \code{status} parameter is one of the following: 

\bigskip
{\small
\begin{tabular}{|ll|} \hline
{\bf Macro Name}                 & {\bf Description} \\ \hline
\code{GST\_STATUS\_OPTIMAL}      & Optimal solution is available  \\
\code{GST\_STATUS\_INFEASIBLE}   & Problem is infeasible \\
\code{GST\_STATUS\_FEASIBLE}     & Search incomplete, feasible solution(s) known \\
\code{GST\_STATUS\_NO\_FEASIBLE} & Search incomplete, no feasible solutions known \\
\code{GST\_STATUS\_NO\_SOLUTION} & Solver never invoked/hypergraph changed \\
 \hline
\end{tabular}}

An example is given in Section~\ref{low_level_interfaces}
(Figure~\ref{fig:demo4} on page~\pageref{fig:demo4}).

\clearpage\func{gst\_hg\_solution}
\label{gst_hg_solution}
\index{gst\_hg\_solution}

\hrule
\vskip 0.25in
Retrieve (one of) the best feasible solutions currently known for a
given solution state object.

\begin{verbatim}
int gst_hg_solution (gst_solver_ptr  solver,
                     int*            nedges,
                     int*            edges,
                     double*         length,
                     int             rank);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{solver} &
\adescr{Solution state object. }\\
\hline
\code{nedges} &
\adescr{Number of edges in the returned solution tree. }\\
\hline
\code{edges} &
\adescr{Array of edge numbers in the returned solution tree. }\\
\hline
\code{length} &
\adescr{Length of the returned tree. }\\
\hline
\code{rank} &
\adescr{Rank of the solution that should be returned, where 0 is the best solution (see also discussion below).   }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

The maximal number of feasible solutions that will be retained by
the solver is determined by
the parameter \code{GST\_PARAM\_NUM\_FEASIBLE\_SOLUTIONS}. However,
for a given solution state object, the actual number of feasible
solutions may be less than this maximum --- and even zero.

The function returns \code{GST\_ERR\_RANK\_OUT\_OF\_RANGE} when
\code{rank} is less than 0 or greater than or equal to the number of
feasible solutions available.
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We assume that solver is a solution state object.
   This code prints all feasible solutions ordered by their rank. */

int i, rank = 0;
int nedges;
int* edges; 
double length;

while (1) {
   /* Get number of edges in this solution. 
      Exit when no more solutions are available. */ 
   if (gst_hg_solution (solver, &nedges, NULL, NULL, rank) != 0) 
      break;

   /* Get edge indices and length of solution. */
   edges = (int *) malloc (nedges * sizeof (int));
   gst_hg_solution (solver, NULL, edges, &length, rank);

   /* Print edge indices and length. */
   printf ("Rank %d: Length is %f. Edges:", rank, length);
   for (i = 0; i < nedges; i++)
      printf(" %d", edges[i]);
   printf("\n");
   free (edges);
   rank++;
}
\end{verbatim}
}
\clearpage\func{gst\_get\_solver\_properties}
\label{gst_get_solver_properties}
\index{gst\_get\_solver\_properties}

\hrule
\vskip 0.25in
Return the property list associated with a solution state object.

\begin{verbatim}
gst_proplist_ptr 
    gst_get_solver_properties (gst_solver_ptr  solver);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{solver} &
\adescr{Solution state object.  }\\
\hline
\end{tabular}

Returns the property list.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* We assume that solver is defined ...*/
double lower_bound;

if (!gst_get_dbl_property(gst_get_solver_properties(solver), 
                          GST_PROP_SOLVER_LOWER_BOUND,
                          &lower_bound) {
   printf("Lower bound for solver object is %f\n", lower_bound);
}
\end{verbatim}
}
\clearpage\subsection{Message handling functions}
\label{message_functions}
All output messages from \geosteiner{} are passed through
user-controllable channels. A given channel may write its output to
more than one output (screen/files). Channels have type
\code{gst\_channel\_ptr}. 

In this section we describe the functions for creating and freeing
channels, for adding output (screen/files) to a channel, and the basic
functions for writing to channels.

\clearpage\func{gst\_create\_channel}
\label{gst_create_channel}
\index{gst\_create\_channel}

\hrule
\vskip 0.25in
Create a channel with an optional set of options. By default, output
is unformatted. In the current version, the only formatted output is
Postscript; see function {\bf gst\_channel\_setopts()} for an example of
how to activate Postscript formatting. Consult \code{geosteiner.h} for
the detailed structure of \code{gst\_channel\_options}.

\begin{verbatim}
gst_channel_ptr 
    gst_create_channel 
        (const gst_channel_options*  chanopts, 
         int*                        status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chanopts} &
\adescr{Channel options (if \code{NULL} then default options are used). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the new channel object.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Create a channel with default options. 
   Ignore returned status. */
gst_channel_ptr chan;
chan = gst_create_channel(NULL, NULL);
\end{verbatim}
}
\clearpage\func{gst\_free\_channel}
\label{gst_free_channel}
\index{gst\_free\_channel}

\hrule
\vskip 0.25in
Free a channel and all its destinations.

\begin{verbatim}
int gst_free_channel (gst_channel_ptr  chan);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel object. Does nothing if \code{NULL}.   }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that chan is an existing channel object */
gst_free_channel (chan);

/* All memory used by chan is now freed */
\end{verbatim}
}
\clearpage\func{gst\_channel\_getopts}
\label{gst_channel_getopts}
\index{gst\_channel\_getopts}

\hrule
\vskip 0.25in
Get channel options.

\begin{verbatim}
int gst_channel_getopts 
        (gst_channel_ptr       chan,
         gst_channel_options*  options);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel opbject. }\\
\hline
\code{options} &
\adescr{Pointer to the channel option structure where channel options should be returned.  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that chan is a channel */
gst_channel_options chanopts;

/* Get options and active Postscript output */
gst_channel_getopts (chan, &chanopts);
chanopts.flags |= GST_CHFLG_POSTSCRIPT;
gst_channel_setopts (chan, &chanopts);
\end{verbatim}
}
\clearpage\func{gst\_channel\_setopts}
\label{gst_channel_setopts}
\index{gst\_channel\_setopts}

\hrule
\vskip 0.25in
Set channel options.

\begin{verbatim}
int gst_channel_setopts 
        (gst_channel_ptr             chan,
         const gst_channel_options*  options);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel opbject. }\\
\hline
\code{options} &
\adescr{Pointer to the channel option structure that contains new channel options.   }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that chan is a channel */
gst_channel_options chanopts;

/* Get options and active Postscript output */
gst_channel_getopts (chan, &chanopts);
chanopts.flags |= GST_CHFLG_POSTSCRIPT;
gst_channel_setopts (chan, &chanopts);
\end{verbatim}
}
\clearpage\func{gst\_channel\_add\_file}
\label{gst_channel_add_file}
\index{gst\_channel\_add\_file}

\hrule
\vskip 0.25in
Add a file destination to a channel.

\begin{verbatim}
gst_dest_ptr 
    gst_channel_add_file (gst_channel_ptr  chan,
                          FILE*            fp,
                          int*             status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel object. }\\
\hline
\code{fp} &
\adescr{File handle. }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the new destination object (of type \code{gst\_dest\_ptr}).

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Setup a channel for stdout */
gst_channel_ptr chan;

chan = gst_create_channel (NULL, NULL);
gst_channel_add_file (chan, stdout, NULL);
\end{verbatim}
}
\clearpage\func{gst\_channel\_add\_functor}
\label{gst_channel_add_functor}
\index{gst\_channel\_add\_functor}

\hrule
\vskip 0.25in
Add a function as destination to a channel.

\begin{verbatim}
typedef size_t 
    gst_channel_func (const char*  buf,
                      size_t       cnt,
                      void*        handle);
gst_dest_ptr 
    gst_channel_add_functor 
                     (gst_channel_ptr    chan,
                      gst_channel_func*  func,
                      void*              handle,
                      int*               status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel object. }\\
\hline
\code{func} &
\adescr{Function that should be added as destination. }\\
\hline
\code{handle} &
\adescr{Handle used for passing error codes from the function back to the application. }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the new destination object (of type \code{gst\_dest\_ptr}).
\newpage

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
static void
 output_text_to_GUI (void *       handle,
                     const char * text,
                     size_t       nbytes)
{
Widget *            widget = handle;
   my_gui_write_text_to_text_widget (widget, text, nbytes);
}

int main (int argc, char **argv)
{
int               status;
Widget *          widget = my_gui_create_text_widget ();
gst_channel_ptr   mychan = gst_create_channel (NULL, NULL);
gst_param_ptr     myparm = gst_create_param (NULL);

    /* Add functor to write output to GUI window. */
    gst_channel_add_functor (mychan,
                             output_text_to_GUI,
                             widget,
                             &status);
    gst_set_cnh_param (myparm,
                       GST_PARAM_PRINT_SOLVE_TRACE,
                       mychan);
    /* Problems solved using myparm will send */
    /* trace output to the GUI window. */
}
\end{verbatim}
}
\clearpage\func{gst\_channel\_rmdest}
\label{gst_channel_rmdest}
\index{gst\_channel\_rmdest}

\hrule
\vskip 0.25in
Remove a destination from a channel.

\begin{verbatim}
int gst_channel_rmdest (gst_dest_ptr  dest);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{dest} &
\adescr{Destination that should be removed.  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that dest is a destination object */
gst_channel_rmdest (dest);

/* Destination object dest is now removed from its channel */
\end{verbatim}
}
\clearpage\func{gst\_channel\_write}
\label{gst_channel_write}
\index{gst\_channel\_write}

\hrule
\vskip 0.25in
Write a string to all destinations in a channel.

\begin{verbatim}
int gst_channel_write (gst_channel_ptr  chan,
                       const char*      text,
                       size_t           nbytes);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel object. }\\
\hline
\code{text} &
\adescr{Buffer with text that should be written. }\\
\hline
\code{nbytes} &
\adescr{Number of bytes in buffer.  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that chan is a channel. */
char* hello = "Hello, World!\n";
gst_channel_write (chan, hello, strlen(hello));
\end{verbatim}
}
\clearpage\func{gst\_channel\_printf}
\label{gst_channel_printf}
\index{gst\_channel\_printf}

\hrule
\vskip 0.25in
Print a formatted string to all destinations in a channel.

\begin{verbatim}
int gst_channel_printf (gst_channel_ptr  chan,
                        const char*      format,
                        ...) _GST_PRINTF_ARGS (2,3);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{chan} &
\adescr{Channel object. }\\
\hline
\code{format} &
\adescr{Printf formatting string. }\\
\hline
\code{...} &
\adescr{Arguments for formatting string.  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Let chan be a channel, and let i1 and i2  
   be two integer variables. */
gst_channel_printf (chan, "i1 = %d  i2 = %d\n", i1, i2);
\end{verbatim}
}
\clearpage\subsection{Input and output functions}
\label{io_functions}
A number of functions are provided for input and output of
hypergraphs. The input/output format can be chosen using
parameters. Scaling information can be associated with input points,
and numbers can be printed in unscaled using this information.

\clearpage\func{gst\_create\_scale\_info}
\label{gst_create_scale_info}
\index{gst\_create\_scale\_info}

\hrule
\vskip 0.25in
Create a scaling information object.

\begin{verbatim}
gst_scale_info_ptr gst_create_scale_info (int* status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the new scaling information object.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Create a new scaling information object
   and use it to hold scaling information for 
   a set of points read from stdin. */
int n;
double* terms;
gst_scale_info_ptr scinfo;

scinfo = gst_create_scale_info (NULL);
n = gst_get_points (stdin, 0, &terms, scinfo);
\end{verbatim}
}
\clearpage\func{gst\_free\_scale\_info}
\label{gst_free_scale_info}
\index{gst\_free\_scale\_info}

\hrule
\vskip 0.25in
Free a scaling information object.

\begin{verbatim}
int gst_free_scale_info (gst_scale_info_ptr scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{scinfo} &
\adescr{Scaling information object that should be freed.  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that scinfo is a scaling information object */
gst_free_scale_info (scinfo);

/* All memory used by scinfo is now freed */
\end{verbatim}
}
\clearpage\func{gst\_get\_points}
\label{gst_get_points}
\index{gst\_get\_points}

\hrule
\vskip 0.25in
Reads a point set from a file (e.g., stdin). Point coordinates should be
separated by whitespace. Reads until end-of-file or until
a specified number of points have been read. 

A scaling information object can be associated with the set of points
that are read; if such an object is passed as an argument, this function
attempts to find an appropriate scaling for the points to
maximize the accuracy of the internal (double) representation. If the
scaling information object is \code{NULL}, no scaling is performed.

\begin{verbatim}
int gst_get_points (FILE*               fp,
                    int                 maxpoints,
                    double**            points,
                    gst_scale_info_ptr  scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{fp} &
\adescr{Input file to read from. }\\
\hline
\code{maxpoints} &
\adescr{Maximum number of points to read (if zero then read until end-of-file). }\\
\hline
\code{points} &
\adescr{Array containing read points (which must be allocated by the user {\em except} when \code{maxpoints = 0}).  }\\
\hline
\code{scinfo} &
\adescr{Scaling information object.  }\\
\hline
\end{tabular}

Returns the number of read points.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Read a set of points from stdin (until end-of-file). 
   A scaling information object is used. */
int n;
double* terms;
gst_scale_info_ptr scinfo;

scinfo = gst_create_scale_info (NULL);
n = gst_get_points (stdin, 0, &terms, scinfo);
\end{verbatim}
}
\clearpage\func{gst\_compute\_scale\_info\_digits}
\label{gst_compute_scale_info_digits}
\index{gst\_compute\_scale\_info\_digits}

\hrule
\vskip 0.25in
Set up various parameters needed for outputting scaled
coordinates. Coordinates/distances are printed with the minimum
fixed precision whenever this gives the exact result, that is, if all
terminal coordinates are integral, they should always be written
without a decimal point. Otherwise we will print the
coordinates/distances with full precision.

\begin{verbatim}
int gst_compute_scale_info_digits 
        (int                 nterms,
         double*             terms,
         gst_scale_info_ptr  scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{nterms} &
\adescr{Number of terminals. }\\
\hline
\code{terms} &
\adescr{Terminals in an array of doubles ($x_1, y_1, x_2, y_2, \ldots$) }\\
\hline
\code{scinfo} &
\adescr{Scaling information object that should be modified.  }\\
\hline
\end{tabular}

Returns zero if operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that terms holds a set of n terminals
   and that scinfo is an associated scaling 
   information object. Find the minimum number of digits 
   necessary when printing unscaled coordinates. */
gst_compute_scale_info_digits (n, terms, scinfo);
\end{verbatim}
}
\clearpage\func{gst\_unscale\_to\_string}
\label{gst_unscale_to_string}
\index{gst\_unscale\_to\_string}

\hrule
\vskip 0.25in
Convert a given internal scaled coordinate to a
printable unscaled ASCII string.  The internal form is in most
cases an integer (to eliminate numeric problems), but the unscaled data 
may involve decimal fractions. 

\begin{verbatim}
char* gst_unscale_to_string 
          (char*               buffer,
           double              val,
           gst_scale_info_ptr  scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{buffer} &
\adescr{Write unscaled string to this buffer. It should be allocated to hold at least 32 characters. }\\
\hline
\code{val} &
\adescr{Double value that should be unscaled. }\\
\hline
\code{scinfo} &
\adescr{Scaling information object.  }\\
\hline
\end{tabular}

Returns a pointer to a string holding the unscaled value.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Print a set of n terminals in array terms 
   to channel chan. Scaling information is 
   given by scinfo. */ 
int i;
char buf1[32], buf2[32];

for (i = 0; i < n; i++) {
   gst_unscale_to_string (buf1, terms[2*i],   scinfo);
   gst_unscale_to_string (buf2, terms[2*i+1], scinfo);
   gst_channel_printf (chan, "(%s, %s)\n", buf1, buf2);
}
\end{verbatim}
}
\clearpage\func{gst\_unscale\_to\_double}
\label{gst_unscale_to_double}
\index{gst\_unscale\_to\_double}

\hrule
\vskip 0.25in
Convert a given internal form coordinate to an unscaled double.

\begin{verbatim}
double gst_unscale_to_double 
           (double              val,
            gst_scale_info_ptr  scinfo);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{val} &
\adescr{Double value that should be unscaled. }\\
\hline
\code{scinfo} &
\adescr{Scaling information object.  }\\
\hline
\end{tabular}

Returns an unscaled double approximation.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Compute an unscaled array of terminal coordinates 
   from a scaled set of n terminals in array terms. 
   Scaling information is given by scinfo. */ 
int i;
double* unscaled_terms;

unscaled_terms = (double *) malloc (2 * n * sizeof (double));

for (i = 0; i < 2*n; i++) {
   unscaled_terms[i] = gst_unscale_to_double (terms[i], 
                                              scinfo);
}
\end{verbatim}
}
\clearpage\func{gst\_load\_hg}
\label{gst_load_hg}
\index{gst\_load\_hg}

\hrule
\vskip 0.25in
Load a hypergraph from an input file. The function creates a new
hypergraph and adds the vertices and edges read from the input
file. The file format must be one of the FST data formats given in
Appendix~\ref{sec:fst_formats}. 

\begin{verbatim}
gst_hg_ptr gst_load_hg (FILE*          fp,
                        gst_param_ptr  param,
                        int*           status);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{fp} &
\adescr{Input file to read from. }\\
\hline
\code{param} &
\adescr{Parameter set (currently not used). }\\
\hline
\code{status} &
\adescr{Status code (zero if successful).  }\\
\hline
\end{tabular}

Returns the hypergraph that is read.

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Load a hypergraph from stdin */
gst_hg_ptr H;
H = gst_load_hg (stdin, NULL, NULL);
\end{verbatim}
}
\clearpage\func{gst\_save\_hg}
\label{gst_save_hg}
\index{gst\_save\_hg}

\hrule
\vskip 0.25in
Print a hypergraph to a file. The print format can be specified by
parameter \code{GST\_PARAM\_SAVE\_FORMAT}.

\begin{verbatim}
int gst_save_hg (FILE*          fp,
                 gst_hg_ptr     H,
                 gst_param_ptr  param);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{fp} &
\adescr{Print to this file. }\\
\hline
\code{H} &
\adescr{Hypergraph that should be printed. }\\
\hline
\code{param} &
\adescr{Parameter set (\code{NULL}=default parameters).  }\\
\hline
\end{tabular}

Returns zero if the operation was successful and non-zero
otherwise. 

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Print a hypergraph H to stdout using 
   the default print format */
gst_save_hg (stdout, H, NULL);
\end{verbatim}
}
\clearpage\subsection{Miscellaneous functions}
\label{miscellaneous_functions}
In this section we describe a few miscellaneous functions, e.g.,
asynchronous functions that may be used by signal handlers.

\clearpage\func{gst\_deliver\_signals}
\label{gst_deliver_signals}
\index{gst\_deliver\_signals}

\hrule
\vskip 0.25in
This function is designed to be safely callable from a signal
handler. The given signals are delivered to the given solver,
which responds to them at some point in the near future.
The signals parameter is the bit-wise OR of one or more special
signal values defined below.  

\begin{verbatim}
void gst_deliver_signals (gst_solver_ptr  solver,
                          int             gstsignals);

\end{verbatim}

\begin{tabular}{ll}
~\hspace*{3cm} & \hspace*{8cm}\\ \hline
\code{solver} &
\adescr{Solution state object. }\\
\hline
\code{gstsignals} &
\adescr{Bit vector defining the signals that should be delivered to the solver; see table below for a list of possible signals.  }\\
\hline
\end{tabular}

Returns nothing.

The following is a list of possible signals that can be delivered to
the solver:

\bigskip
{\small
\begin{tabular}{|ll|} \hline
{\bf Macro Name}                  & {\bf Description} \\ \hline
\code{GST\_SIG\_ABORT}            & Abort computation \\
\code{GST\_SIG\_FORCE\_BRANCH}    & Stop cutting and force a branch \\
\code{GST\_SIG\_STOP\_TEST\_BVAR} & Stop testing branch variables and \\
                                  & use the best one seen so far \\
\code{GST\_SIG\_STOP\_SEP}        & Abort the separation routines \\
                                  & and continue with all cuts \\
                                  & discovered so far \\
 \hline
\end{tabular}}

\bigskip{}Example:
{\footnotesize
\begin{verbatim}
/* Assume that solver is a solution state object. 
   Deliver a signal to force a branch. */
gst_deliver_signals (solver, GST_SIG_FORCE_BRANCH);
\end{verbatim}
}

